<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>cpp入门-课件 | lr580&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="lr580,lr580's Blog" />
  
  <meta name="description" content="2022 香农先修班第一次课C++入门      语法基础这次课只介绍与算法相关的 C++ 知识，写算法用得很少的知识(如 try-catch, 类)不予介绍。 基本概念C++ 是 C 的超集，这意味着所有 C 的语法都能直接用于 C++。 C++ 同 C 一样，都分为多个版本。一般而言越新好用的新语法越多。鉴于绝大多数比赛和平台都支持的 C++11，而更新的不一定支持，所以主要使用 C++11。">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp入门-课件">
<meta property="og:url" content="https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/index.html">
<meta property="og:site_name" content="lr580&#39;s blog">
<meta property="og:description" content="2022 香农先修班第一次课C++入门      语法基础这次课只介绍与算法相关的 C++ 知识，写算法用得很少的知识(如 try-catch, 类)不予介绍。 基本概念C++ 是 C 的超集，这意味着所有 C 的语法都能直接用于 C++。 C++ 同 C 一样，都分为多个版本。一般而言越新好用的新语法越多。鉴于绝大多数比赛和平台都支持的 C++11，而更新的不一定支持，所以主要使用 C++11。">
<meta property="og:locale">
<meta property="article:published_time" content="2022-10-31T10:57:30.000Z">
<meta property="article:modified_time" content="2022-10-31T10:58:58.647Z">
<meta property="article:author" content="lr580">
<meta property="article:tag" content="md">
<meta property="article:tag" content="香农先修班">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">lr580&#39;s 博客</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        lr580&#39;s 博客
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        建设期，不定期更新。
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Github" target="_blank" href="//github.com/lr580">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="2277379149"  ">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                        <a title="洛谷博客" target="_blank" href="//lr580.blog.luogu.org">
                            <i class="fa fa-user-o fa-2x"></i></a>
                    
                        <a title="友链(asympto69的博客)" target="_blank" href="//asympto69.github.io">
                            <i class="fa fa-handshake fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-cpp入门-课件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      cpp入门-课件
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2022-10-31
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="2022-香农先修班第一次课"><a href="#2022-香农先修班第一次课" class="headerlink" title="2022 香农先修班第一次课"></a>2022 香农先修班第一次课</h1><div style="background-color:#feeeed;color:#fe4c61;font-size:26px;font-weight:900" align="center">C++入门</div>



<div style="page-break-after: always;"></div>

<h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><p>这次课只介绍与算法相关的 C++ 知识，写算法用得很少的知识(如 <code>try-catch</code>, 类)不予介绍。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++ 是 C 的超集，这意味着所有 C 的语法都能直接用于 C++。</p>
<p>C++ 同 C 一样，都分为多个版本。一般而言越新好用的新语法越多。鉴于绝大多数比赛和平台都支持的 C++11，而更新的不一定支持，所以主要使用 C++11。具体如何配置自行百度。</p>
<blockquote>
<p>推荐的开发环境首选 vscode(即visual studio code蓝色图标的)，自行了解。可以自行下载好用的插件。vscode 两大好处是边写边报错和自动格式化。</p>
</blockquote>
<p>C++ 的文件后缀一般是 <code>.cpp</code>(还有别的后缀，但最常用是这个)。头文件后缀可以是 <code>.hpp</code>。</p>
<p>C++ 的优势是具有大量的 STL(标准模板库)，提供很多内置的库函数和数据结构，所以我们推荐使用 C++ 而不是 C。在算法竞赛里，对效率要求很严格，因为 Python 和 Java 是解释型语言，效率低，所以不推荐使用。其他语言通常并不是所有算法竞赛都支持。(至少 C++ 按理是每个算法竞赛都会支持的)</p>
<h3 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h3><p>C++ 的一大优点是，可以只引用一个头文件，称为万能头文件，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果你打开该文件的源码，会发现它的本质就是把大部分库都 <code>#include</code> 了一次。(源码请见<a target="_blank" rel="noopener" href="http://t.zoukankan.com/sjbin-p-14467202.html">这里</a>)</p>
<blockquote>
<p>优点显而易见，就是可以不用记忆各个函数在哪个头文件，也不用写一堆 include。</p>
<p>有一些潜在但通常无伤大雅的缺点：</p>
<ul>
<li><p>因为把所有库都调了一边，所以自带很多常量和函数名，容易重名。典型的重名有：<code>copy,sort,x1,y1,x0,y0,xn,yn,prev,size,merge</code> 等。</p>
<p>同时，因为需要加载大量头文件，效率有些微下降(可忽略不计)。</p>
</li>
<li><p>万能头不是GNU C++标准头文件，并不是所有 OJ 都支持万能头(已知 POJ 不支持)。</p>
</li>
<li><p>部分开发环境(如紫色的visual studio)没有该头文件，需要自己装。</p>
</li>
</ul>
</blockquote>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>为了避免重名冲突，C++ 的库函数一般是不能直接调用的，而是定义了一个叫做命名空间的前缀，需要使用作用域解析运算符才能调用。默认命名空间名字叫 <code>std</code>(即 standard)。所以对一个函数，调用方法是 <code>std::函数()</code>。</p>
<p>例如，已知 C++ 有一个名为 <code>sort</code> 的函数，调用的代码举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(a,a+<span class="number">3</span>); <span class="comment">//调用函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>如果需要大量调用库函数，显然这样会徒增很多码量。为了能够像 C 一样调用库函数，需要声明使用命名空间 <code>std</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<p>连起来的完整代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">//万能头</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//命名空间</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">3</span>); <span class="comment">//调用库函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于其他命名空间和自定义命名空间，不讲，感兴趣自学。sort 函数预计会在后续课程详细讲解，这里从略。</p>
<p>部分算法选手喜欢写成 <code>signed main()</code> 或 <code>int32 main()</code>，其实是一样的意思。这样写是以防如果需要把全文 <code>int</code> 替换成 <code>long long</code>，即使用 <code>#define int long long</code> 时，因为不允许 <code>main</code> 函数的返回值是 <code>long long</code>，所以需要让 <code>main</code> 不被替换而采取的策略。 如果没有空间严格限制，可以推荐用 <code>long long</code> 取代全部 <code>int</code>，视个人喜好决定是否遵循该推荐。</p>
<p>习惯上，数组变量放全局。这是因为每个函数的内存上限约为 2MB。而全局无限制。如果不放全局的静态数组大于 2MB 就会 RE。而且全局能够自动各元素初始化为 0。而且事实上习惯每个数组都比所需大小开多几个元素。</p>
<p>对数组，有两种代码风格，一种是从下标 0 开始使用，另一种是从下标 1 开始使用。看个人喜好。</p>
</blockquote>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>我们知道，在 C 语言，输入和输出不同类型的变量需要使用不同的占位符。但是在 C++ 可以统一使用一种格式。</p>
<blockquote>
<p>C++ 可以完全用 C 的输入输出，下文只是另一种新的方法，不强制使用。</p>
<p>如果对输入输出整体不理解，可以推荐拓展阅读。并请注意在 OJ 输入和输出是可以同步进行的，如你可以读入第一行再输出一些东西再读入第二行再输出，不必全部读入再全部输出……最终只需要你输出的内容合起来与答案一致即可</p>
</blockquote>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><h5 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h5><p>使用·<code>cin</code> 函数输入一个变量，表达式是 <code>cin&gt;&gt;变量名</code>。可以连写表示输入多个变量，如 <code>cin&gt;&gt;x1&gt;&gt;x2;</code>，等效于 <code>cin&gt;&gt;x1;cin&gt;&gt;x2;</code>。变量类型不同其等效表达式也不同：</p>
<ul>
<li><p>各种整型与浮点型：等效于 <code>scanf</code></p>
</li>
<li><p>字符数组(char*)：等效于 <code>scanf</code></p>
</li>
<li><p>字符(char)：不等效于任何一个 C 语言函数。会读取第一个输入流的非空(非空白回车等)字符。</p>
<blockquote>
<p>算法竞赛里无论 C/C++，除非对I/O流很熟悉，否则不建议读取 <code>char</code>，一般当成字符数组/字符串读入然后取首字符。</p>
</blockquote>
</li>
</ul>
<p><code>cin&gt;&gt;变量名</code> 这个表达式本身会返回一个布尔值，代表当前是否读取到 EOF；为真表示遇到了 EOF。</p>
<p>使用举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line"><span class="type">char</span> s[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf%c&quot;</span>, x + y, s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/*input:5 0.8 x output:5.80x*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> v, s;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; v)</span><br><span class="line">    &#123; <span class="comment">//类比EOF!=scanf(&quot;%d&quot;,&amp;v)</span></span><br><span class="line">        s += v;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别提一下，有一个函数为 <code>cin.ignore()</code>，作用是读走一个输入流字符，等效于 <code>getchar()</code>。</p>
<h5 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h5><p>如果要读取一整行内容，一种方法是使用 <code>cin.getline</code> 成员函数。一种语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(字符数组变量名, 读取长度, 终止字符)</span><br></pre></td></tr></table></figure>
<p>将终止字符设置为 <code>\n</code>，那么读取到的长度是从当前输入流到 <code>\n</code> 前(不含 <code>\n</code>)的全部内容。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">getline</span>(s, <span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strlen</span>(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/*input:hello world output:11*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有 <code>getline</code> 函数。下文叙述。</p>
<p>更多函数，例如 <code>peek</code>，用处不是特别大，感兴趣可自行了解。</p>
</blockquote>
<p>顺便提一下，<code>gets</code> 函数是被 C11 和 C++11 等标准禁用了的，请使用 <code>fgets</code> 或 <code>cin.getline</code> 代替。</p>
<blockquote>
<p>同样被高版本(不一定是11，但有的更高的会禁用)禁用的功能还有：<code>register</code> 和 <code>random_shuffle</code> 等，建议有使用这些语法的尽量改掉。</p>
</blockquote>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>使用 <code>cout</code> 函数输出一个表达式。格式为 <code>cout&lt;&lt;表达式</code>。注意 <code>&lt;&lt;</code> 本质是位运算，为避免歧义和优先级问题，所以含位运算、四则运算的表达式可能需要加括号。具体优先级表自查。</p>
<p>输出的语法与输入是类似的。一些细节：</p>
<ul>
<li>输出整数、字符、字符数组跟最普通的 <code>printf</code> 一样</li>
<li>输出浮点数，默认六位<strong>有效数字</strong>(注意不是小数点后六位)，大于六位数用指数输出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> x, y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;+&#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; (x + y) &lt;&lt; <span class="string">&quot;\nI&#x27;m smart!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/*input:2333333 4.0 output(1st line):2.33333e+06+4=2.33334e+06*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>你也许听过 <code>endl</code> 可以“代替” <code>\n</code>，但强烈不推荐使用。</p>
<p>如果要输出特定位小数，如保留小数点后九位，建议使用 C 语言的 <code>printf</code>。C++ 的 <code>cout</code> 能做，但是相比之下更复杂。感兴趣自行百度。</p>
</blockquote>
<h4 id="读写加速"><a href="#读写加速" class="headerlink" title="读写加速"></a>读写加速</h4><p>通常情况下，C 语言 <code>printf/scanf</code> 的极限约为每秒 $10^6$ 个非数组变量。但未加优化 C++ 的 <code>cout/cin</code> 的极限才约为 $2\times10^5$，为了加速到接近 C 语言速度，通常需要加上三行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//false即0,是C++的布尔值bool类型</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); <span class="comment">//0即空指针，可以写成C++的nullptr或C语言的NULL</span></span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; x * x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了读写加速后，不能同时使用 <code>cin,scanf</code> 与 <code>cout,printf</code>，否则可能出错</p>
<blockquote>
<p>想要比 $10^6$ 更快，需要手写读入/输出函数，称为快读/快写，一般用不上，感兴趣自学。</p>
</blockquote>
<h3 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h3><blockquote>
<p>我们知道，在 C 语言，有传址与传值之分，例如交换一个变量可以写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myswap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> t = *x;</span><br><span class="line"> *x = *y;</span><br><span class="line"> *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> x = <span class="number">580</span>, y = <span class="number">1437</span>;</span><br><span class="line"> myswap(&amp;x, &amp;y);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这样写太麻烦了。而在 C++，有对传值的简化写法。</p>
</blockquote>
<p>使用 <code>变量类型&amp; 传引用变量名</code> 定义一个传引用变量(称为左值传引用)。作用跟指针类似，但不需要指针语法，只需要按一般变量语法使用即可。</p>
<blockquote>
<p>有右值传引用 <code>&amp;&amp;</code>，基本用不上，感兴趣自学。</p>
</blockquote>
<p>赋值一个传引用变量，直接把变量赋给它即可，即 <code>传引用变量名 = 被引用变量名</code>。声明时必须赋值，且不能改变初始化再指向其他对象。</p>
<p>传引用可以视作一个变量的别名。即调用传引用等效于调用被引用变量本身。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">114515</span>;</span><br><span class="line">    <span class="type">int</span> &amp;y = x;</span><br><span class="line">    --y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, y, x);<span class="comment">//都是114514</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可以在函数里，直接用传引用实现传址功效。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">233</span>, b = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b; <span class="comment">// 666 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上，C++ 内置了 <code>swap</code> 函数，可以直接调用来实现上述功能。 </p>
</blockquote>
<p>传引用的功能是代替指针。特别注意不能传引用一个数组。</p>
<p>使用传引用的目的：</p>
<ul>
<li>修改值</li>
<li>对很大的数据对象(结构体)，提高运行速度，避免拷贝</li>
</ul>
<blockquote>
<p>对于认为不需要修改值的用途里，可以写成 <code>const 类型&amp; 变量</code>。这在重载比较函数里很常用。</p>
</blockquote>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>与 C 语言的结构体不同，C++ 的结构体有一些新的特点。</p>
<p>首先，可以更简单的声明(不需要使用 typedef 等一堆东西)。格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名字 &#123;结构体定义&#125;;</span><br></pre></td></tr></table></figure>
<p>可以在声明结构体时马上再定义该结构体的变量，也可以单独定义，格式分别是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名字 &#123;结构体定义&#125; 变量名<span class="number">1</span>;</span><br><span class="line">结构体名字 变量名;</span><br></pre></td></tr></table></figure>
<p>在定义时，可以用大括号法依次给成员赋值。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = &#123;成员<span class="number">1</span>值, 成员<span class="number">2</span>值, ... 成员n值&#125;;</span><br></pre></td></tr></table></figure>
<p>当然也可以像 C 语言那样在后续再赋值。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; a = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">node b = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, c;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printnode</span><span class="params">(node x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//对于比较大的结构体，可以node&amp; x提高效率避免复制</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) &quot;</span>, x.x, x.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c.x = <span class="number">6</span>;</span><br><span class="line">    c.y = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printnode</span>(a);</span><br><span class="line">    <span class="built_in">printnode</span>(b);</span><br><span class="line">    <span class="built_in">printnode</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>与 C 语言不同，C++ 的结构体可以还能定义成员函数(称为方法)。如果学过面向对象，可以认为 C++ 的结构体是默认全是公有成员的类，每个结构体变量是实例。</p>
<p>方法的定义和调用跟一般函数是类似的，只不过需要多用一次 <code>.</code> 直接成员运算符或 <code>-&gt;</code> 间接成员运算符(如果用了结构体指针，一般很少用)。</p>
<p>方法可以不使用成员运算符直接调用自己的成员属性。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) &quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node <span class="title">add</span><span class="params">(node r)</span> <span class="comment">//不修改r的话建议写成const node&amp; r</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + r.x, y + r.y&#125;;</span><br><span class="line">    &#125; <span class="comment">//大括号是定义结构体的一种方法</span></span><br><span class="line">&#125; a = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, b = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, c = &#123;<span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">    node d = a.<span class="built_in">add</span>(c);</span><br><span class="line">    d.<span class="built_in">print</span>();</span><br><span class="line">    (a.<span class="built_in">add</span>(b)).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上文提到的 <code>cin.getline</code> 函数，实际上就是 <code>cin</code> 这个类的 <code>getline</code> 方法。</p>
<p>对比参数 <code>node x</code>, <code>node&amp; x</code> 与 <code>const node&amp; x</code>：</p>
<ol>
<li><code>node x</code> 需要复制一遍 x 作为参数，传值；x 可以是变量或常量、表达式</li>
<li><code>node&amp; x</code> x 一定变量，不能是常量或表达式；传址。</li>
<li><code>const node&amp; x</code> 传址，不能修改 x，只能读取。可以是变量、常量、表达式。</li>
</ol>
<p>如：(上述代码为例)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a.<span class="built_in">add</span>(b)).<span class="built_in">print</span>(); <span class="comment">//1,2,3可以(2,3传址)</span></span><br><span class="line">(((node)&#123;<span class="number">3</span>, <span class="number">4</span>&#125;).<span class="built_in">add</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)).<span class="built_in">print</span>(); <span class="comment">//1,3可以(3传址)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>对于基本运算符，如关系运算  <code>+-*/%</code>，比较运算 <code>!=,&gt;</code>，位运算等，可以给结构体重载，使得结构体支持直接使用该运算。有两种方法，一种是在结构体内写方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值 <span class="keyword">operator</span> 运算符(该运算符的右参数) <span class="comment">//可能没有参数</span></span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种是定义函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值 <span class="keyword">operator</span> 运算符(左参数, 右参数)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于二元运算符，如 <code>+</code>，一定有左右参数；对一元运算符如 <code>++</code>，没有右参数。</p>
<p>举例：(写法一：方法)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) &quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + r.x, y + r.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node c = a + a;</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">    (a + (node)&#123;<span class="number">10</span>, <span class="number">10</span>&#125;).<span class="built_in">print</span>();</span><br><span class="line">    ((node)&#123;<span class="number">100</span>, <span class="number">100</span>&#125; + (node)&#123;<span class="number">10</span>, <span class="number">10</span>&#125;).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(写法二：函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) &quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;l, <span class="type">const</span> node &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;l.x + r.x, l.y + r.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node c = a + a;</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">    (a + (node)&#123;<span class="number">10</span>, <span class="number">10</span>&#125;).<span class="built_in">print</span>();</span><br><span class="line">    ((node)&#123;<span class="number">100</span>, <span class="number">100</span>&#125; + (node)&#123;<span class="number">10</span>, <span class="number">10</span>&#125;).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上，<code>cin &gt;&gt;</code> 和 <code>cout &lt;&lt;</code> 的本质就是 <code>cin,cout</code> 两个类的重载函数。</p>
<p>重载比较函数，建议写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; r) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"> 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中前者 <code>const</code> 表示右操作数不会被改变；后者表示左操作数。</p>
<p>或：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp;l, <span class="type">const</span> node&amp; r)</span><br><span class="line">&#123;</span><br><span class="line"> 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面再介绍三个比较好用的特性：</p>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>语义与 C 语言完全不一样。在 C++ 的语义代表智能判定表达式的类型。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;   <span class="comment">//是int类型</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2LL</span>; <span class="comment">//是long long类型</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="number">3.0</span>; <span class="comment">//是double类型</span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">5</span>, a2 = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">auto</span> w = a1 + a2; <span class="comment">// int</span></span><br></pre></td></tr></table></figure>
<p>同理，可以判定结构体，如对上文程序，可以写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = a + a; <span class="comment">//原文是node c = a + a;</span></span><br></pre></td></tr></table></figure>
<p>好处是，遇到很多名字很长的类型名时，可以少写点东西。这在下文很有用。</p>
<blockquote>
<p>注意：auto 不能用于判定不出类型的情形(有歧义)，如函数的参数。</p>
</blockquote>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p>对于一个可迭代的变量，如数组，可以用 <code>for-each</code> 表达式不取下标直接依次把每个元素值调用出来，格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(类型 变量名 : 可迭代变量)</span><br><span class="line">&#123;</span><br><span class="line">    表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v); <span class="comment">//2 4 6 8 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;) <span class="comment">//即int i</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺点是运行速度略慢于一般的 for，但是写起来比较简洁。</p>
<p>在高版本(如C++17和更高)还可以做多元素迭代，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> x, y;</span><br><span class="line">&#125; a[] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : a)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x, y, x + y);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>有一些函数，不需要递归，用得很少，或者很简单，有时往往不希望定义为全局的，导致阅读起来代码结构很乱。这时候可以定义局部函数，即匿名函数。如果把定义结果赋值给一个变量，就成了函数变量。格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[](参数列表)&#123;函数体&#125;; <span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">auto</span> 函数变量名 = [](参数列表)&#123;函数体&#125;; <span class="comment">//函数变量</span></span><br></pre></td></tr></table></figure>
<p>默认不允许在函数体使用全局变量，若需要允许，把 <code>[]</code> 改成 <code>[&amp;]</code>。</p>
<p>调用函数变量与调用函数是一样的。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">    &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">f</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用举例：对 <code>sort</code> 函数，重定义排序规则，将默认升序改为降序排序。<code>sort</code> 函数可以传入第三个参数，类型是函数变量，表示比较依据(返回 <code>true</code> 代表排前面)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">         &#123; <span class="keyword">return</span> x &gt; y; &#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上，C++ 内置了这样的函数变量，需要逆序即使用 <code>greater&lt;类型&gt;()</code> 即可获得该函数变量。升序同理 <code>less&lt;类型&gt;()</code>。如上述代码改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">3</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>事实上递归函数也可以写匿名，但是比较麻烦，而且是 C++14 和更高版本才支持的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">auto</span> print = [](<span class="keyword">auto</span> self, <span class="type">int</span> v) -&gt; <span class="type">void</span></span><br><span class="line"> &#123; <span class="comment">//函数功能：输出正数,-&gt;void是返回值声明为void</span></span><br><span class="line">     <span class="keyword">if</span> (v &gt;= <span class="number">10</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">self</span>(self, v / <span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">putchar</span>((v % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">print</span>(print, <span class="number">1437581</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便提一个重要的友情提示，每个函数(包括main函数)的允许空间大小为 2MB，所以对比较大的静态数组请设置为全局变量，否则可能会运行出错</p>
</blockquote>
<h3 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h3><p>上文定义了 <code>int</code> 的 node，如果需要定义其他类型的，又要重写一遍 node，非常的麻烦。为了具有更高的通用性，可以只定义一个 node，使得所有类型都通用，这种思想就是模板。例如，用模板类(这里准确来说是模板结构体)我们可以改造为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> t&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    t x, y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//因为不知道类型，所以不能printf，占位符未知</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125; <span class="comment">//事实上cout&lt;&lt;就是一个模板方法</span></span><br><span class="line">    node&lt;t&gt; <span class="keyword">operator</span>+(node&lt;t&gt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + r.x, y + r.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&lt;<span class="type">int</span>&gt; x = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, y = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    (x + y).<span class="built_in">print</span>();</span><br><span class="line">    node&lt;<span class="type">double</span>&gt; z = &#123;<span class="number">0.5</span>, <span class="number">0.6</span>&#125;;</span><br><span class="line">    (z + node&lt;<span class="type">double</span>&gt;&#123;<span class="number">0.1</span>, <span class="number">0.2</span>&#125;).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们只定义了一个 node，却可以用很多个类型的数据。</p>
<p>语法简要解释：</p>
<ul>
<li><code>template &lt;typename t&gt;</code> 表示下面的结构体为模板，不确定类型的成员的类型抽象为 <code>t</code>。(即类型本身是变量 <code>t</code>。)</li>
<li><code>t x,y;</code> 是定义了两个成员属性，其类型是不确定的 <code>t</code>。</li>
<li><code>node&lt;t&gt;</code> 表示该 <code>node</code> 结构体所使用的类型值是 <code>t</code>。</li>
<li><code>node&lt;int&gt;</code> 声明了一个具体的 <code>node</code> 结构体变量，即 <code>t=int</code>。</li>
</ul>
<p>对 C++ 入门来说，只需要掌握模板的使用即可，不需要掌握定义。即 <code>main</code> 函数内的部分要求掌握，<code>node</code> 的声明能理解即可。在下文 STL 会出现大量模板的使用。</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL 即 standard template library，标准模板库。顾名思义，定义了很多模板类及其相关的函数的一系列库的即可。</p>
<p>也就是说，STL 所提供的全部类都是模板类。</p>
<blockquote>
<p>下文会出现复杂度的描述。因时间有限，本节课不讲复杂度，可在后续课程学完复杂度后倒回来再看看这部分内容。</p>
</blockquote>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h4><p>直译是向量(即线性代数的单行矩阵)，即一维数组。是动态的。即不定长数组。</p>
<p>常用定义方法有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;数据类型&gt;变量名;</span><br><span class="line">vector&lt;数据类型&gt;变量名&#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, ..., 元素n&#125;;</span><br><span class="line">vector&lt;数据类型&gt;变量名 (长度);</span><br><span class="line">vector&lt;数据类型&gt;变量名 (长度, 初始值);</span><br><span class="line">vector&lt;数据类型&gt;变量名 = 变量名<span class="number">2</span>; <span class="comment">//复制构造</span></span><br><span class="line">vector&lt;数据类型&gt;变量名(变量名<span class="number">2</span>); <span class="comment">//同上</span></span><br><span class="line">vector&lt;数据类型&gt;变量名(数组首地址, 数组尾地址);<span class="comment">//复制[首,尾)</span></span><br></pre></td></tr></table></figure>
<p>可以用 <code>for-each</code> 来简单地输出一个 vector 的所有元素。也可以用 <code>[]</code> 运算符，将其当做数组来使用。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = v1;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v1)</span></span>;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(a, a + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span> <span class="comment">//不复制，提高效率</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v3[<span class="number">0</span>] = <span class="number">1919810</span>;</span><br><span class="line">    v4[<span class="number">1</span>] = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">print</span>(v1);</span><br><span class="line">    <span class="built_in">print</span>(v2);</span><br><span class="line">    <span class="built_in">print</span>(v3);</span><br><span class="line">    <span class="built_in">print</span>(v4);</span><br><span class="line">    <span class="built_in">print</span>(v5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>size()</code> 返回 <code>size_t</code> 类型(类似 <code>unsigned</code> 整型)当前有几个元素。$O(1)$</p>
<p>因为其是 <code>unsigned</code> 的，所以谨慎使用 <code>size()-1</code> 以免 0-1 得到错误。</p>
</li>
<li><p><code>resize(int size, value=0)</code> 改变大小并重新初始化。</p>
<p>即有两个方法，一个是 <code>resize(int size)</code>，一个是 <code>resize(int size, value)</code>。前者默认 <code>value=0</code>。</p>
</li>
<li><p><code>push_back(value)</code> 插入一个元素到最末，size 加一。均摊 $O(1)$</p>
<blockquote>
<p>emplace_back是push_back的优化版，区别如下:(给看得懂的人看)</p>
<p>emplace_back() 在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。(当然int之类的也能用)是C++11的新特性。</p>
</blockquote>
</li>
<li><p><code>pop_back()</code> 删除数组最后的元素， size 减一。$O(1)$</p>
<p>警告：请勿在空 vector 执行该操作，否则可能会 RE。下文的 <code>front, back</code> 同理</p>
</li>
<li><p><code>clear()</code> 清空数组，使 size 为 0。$O(1)$</p>
</li>
<li><p><code>front()</code> 获得首元素的传引用。</p>
</li>
<li><p><code>back()</code> 获得末元素的传引用。</p>
</li>
<li><p><code>begin()</code> 获得首元素的迭代器。</p>
<p>迭代器作用类似指针，可以进行 ++ 和 -- 等来移动，可以 * 来取值。</p>
</li>
<li><p><code>end()</code> 获得末元素的迭代器。</p>
<blockquote>
<p>有 <code>rbegin,rend</code> 迭代器，感兴趣自学。</p>
</blockquote>
</li>
<li><p><code>insert(迭代器 pos, value)</code>，在当前迭代器位置插入元素，当前位置及以后位置往后移，size 加一。$\mathbf{O(n)}$</p>
<p>警告：不要使得迭代器越界，否则会 RE，下文 <code>erase</code> 同理。</p>
<blockquote>
<p>还有更多 insert 的重载方法，感兴趣自学。</p>
</blockquote>
</li>
<li><p><code>erase(迭代器 pos)</code>，删掉当前迭代器位置元素，当前之后的元素往前移，size 减一。$\mathbf{O(n)}$</p>
</li>
<li><p><code>empty()</code> 返回布尔值，代表 vector 是否为空。$O(1)$</p>
</li>
</ul>
<p>使用举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//用上文的for-each也行</span></span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    ++v.<span class="built_in">front</span>();</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器指向的下标，不会随着增删而移位。(通常而言，使用迭代器时，不建议同时进行增删操作；且增删后建议新开迭代器而不是用增删前的，下文的其他 STL 同理)</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *it);</span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>可以造一维 vector 数组，那么第一维是静态的，第二维是 vector 本身是动态的。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; v[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    v[<span class="number">1</span>].<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    v[<span class="number">1</span>].<span class="built_in">back</span>()--;</span><br><span class="line">    cout &lt;&lt; v[<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这样的话无论怎么搞，只有最右维是动态的。如想每个维度都是动态的，需要使用嵌套。</p>
<p>实现多维动态数组，可以使用 vector 套 vector 的方法，做到每一维都是动态的。例如二维嵌套为：<code>vector&lt;vector&lt;基本数据类型&gt;&gt;</code>。</p>
<p>使用构造方法 <code>(长度, value)</code>，其 <code>value</code> 是一个低维 vector，即 <code>vector&lt;基本类型&gt;(长度)</code>。或者用 <code>resize</code>。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//二维动态数组，初始两维长度分别是0,0</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v0, v2;</span><br><span class="line"><span class="comment">//二维动态数组，初始两维长度分别是10,20;值都是0</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v1</span>(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>));</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//动态设置初始大小</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    v2.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    cout &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v1[<span class="number">0</span>].<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    v1[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; v1[<span class="number">0</span>].<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v1[<span class="number">1</span>].<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现第二维的长度是不一的，这比较容易理解。</p>
<p>相似的，如果想要造三维动态数组，可以用下面两种方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">v</span>(<span class="number">5</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">15</span>,<span class="number">1</span>))); <span class="comment">//5,10,15是三个维度的初始长度,元素值全部设为1</span></span><br><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(<span class="number">5</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">15</span>, <span class="number">1</span>)));</span><br></pre></td></tr></table></figure>
<p>更高维依次类推。</p>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>二元对，即两个变量组成的一个数据类型。定义方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;首数据类型, 尾数据类型&gt; 变量名;</span><br><span class="line">pair&lt;首数据类型, 尾数据类型&gt; 变量名 (首, 尾);</span><br><span class="line">pair&lt;首数据类型, 尾数据类型&gt; 变量名 = &#123;首, 尾&#125;;</span><br><span class="line">pair&lt;首数据类型, 尾数据类型&gt; 变量名 = <span class="built_in">make_pair</span>(首, 尾);</span><br></pre></td></tr></table></figure>
<p>成员变量为 <code>first</code> 和 <code>second</code>。</p>
<p>默认重载了比较函数，两个 pair 比较大小，以首数据类型为第一关键字，以尾数据类型为第二关键字进行升序比较。</p>
<p>使用举例：(当然可以不用 vector，单独使用也是可以的)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt; v = &#123;&#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2.4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2.2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//使用pair比较函数进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d %.1lf)\n&quot;</span>, x.first, x.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>三元对。直接使用 <code>&#123;&#125;</code> 构造。取出方法是 <code>tie(变量a, 变量b, 变量c)=tuple变量</code>。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span>&gt; t = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">tie</span>(a, b, c) = t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %c&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++17 等高版本可以用 <code>auto[a,b,c]=t</code>。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span>&gt; t = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %c&quot;</span>, a, b, c);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>栈。符合后进先出(FILO,first in last out)原则，可以认为是每次只能访问、插入和删除尾部(称为栈顶)的动态数组。可以类比摞成一叠的盘子，每次只能操作顶部。</p>
<p>常用方法(都是 $O(1)$)：</p>
<ul>
<li><p><code>size()</code>。同理</p>
</li>
<li><p><code>push(value)</code>。压栈/进栈/入栈。将一个元素放到栈顶</p>
</li>
<li><p><code>pop()</code>。弹栈/出栈。将栈顶元素删除</p>
<p>请勿在栈空时执行该方法，否则会 RE。下文 <code>top</code> 同理</p>
</li>
<li><p><code>top()</code>。输出栈顶元素</p>
</li>
<li><p><code>empty()</code>。同理</p>
</li>
</ul>
<blockquote>
<p>STL 的栈常用于常用于后续课程的滑动窗口、双指针、单调栈等算法。</p>
</blockquote>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>队列。符合先进先出(FIFO, first in first out)原则。可以类比一般的排队。只能够取队列首部，删除队列首部和将元素添加到队列尾部。是特殊的动态数组。</p>
<p>常用方法与栈类似，且也都是 $O(1)$：</p>
<ul>
<li><code>size()</code></li>
<li><code>push(value)</code>。入队。放到队尾。</li>
<li><code>pop()</code>。将队首出队。</li>
<li><code>front()</code>。取队首，注意不是 top。</li>
<li><code>back()</code>。取队尾。显然 <code>pop,front,back</code> 执行前都应保证非队空。</li>
<li><code>empty()</code></li>
</ul>
<blockquote>
<p>STL 的队列(及下文优先级队列)常用于后续课程的 BFS 等算法。</p>
</blockquote>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>优先级队列，即大根堆(最大堆)。是一种按照值大小进行排序的有序队列，并只保证值最大的一定在队首。</p>
<p>与队列常用方法不同是：</p>
<ul>
<li><p>使用 <code>front</code> 而不是 <code>top</code>。</p>
</li>
<li><p>没有 <code>back</code> 方法。</p>
</li>
<li><p>设 $n=size()$，则 <code>push, pop</code> 都是 $O(\log_2n)$。其他不变。</p>
<blockquote>
<p>具体原理可以参考排序算法的堆排序，后续课程可能介绍。</p>
</blockquote>
</li>
</ul>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q.<span class="built_in">top</span>());</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q.<span class="built_in">top</span>());</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q.<span class="built_in">top</span>());</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h4><p>对结构体，需要重载 <code>&lt;</code> 运算符(注意不是 >)，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, i;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;r) <span class="type">const</span> &#123; <span class="keyword">return</span> v &lt; r.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q.<span class="built_in">top</span>().i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>priority_queue&lt;pair&lt;int,int&gt;&gt; q</code> 可以类似实现上述内容，不需要重载，因为 node 与二元组含义类似。</p>
</blockquote>
<h4 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h4><p>如果想要实现小根堆，即每次队首都是最小值，有如下方法：</p>
<ol>
<li><p>每次 <code>push</code> $x$ 时入队相反数 $-x$，每次 <code>top</code> 取出时再取相反数即 $-(-x)$</p>
</li>
<li><p>重新定义模板，设为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;类型, vector&lt;类型&gt;, greater&lt;类型&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>如果类型是自定义类/结构体，需要事先重载 <code>&gt;</code> 运算符(注意不是 \&lt;)</p>
</li>
<li><p>将类型设为结构体，重载 <code>&gt;</code> 运算符，使其表现出小于的含义</p>
</li>
</ol>
<p>如：(第二点)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, i;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node &amp;r) <span class="type">const</span> &#123; <span class="keyword">return</span> v &gt; r.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q.<span class="built_in">top</span>().i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与下文内容等价：(第三点)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, i;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;r) <span class="type">const</span> &#123; <span class="keyword">return</span> v &gt; r.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q.<span class="built_in">top</span>().i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><p>集合。即满足元素互异的动态数组。set 元素是升序排序的。有下面几个较常用的构造方法：①空集；②复制自数组；③复制自 vector；④复制自 set；⑤大括号。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(a, a + <span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(v.begin(), v.end())</span></span>;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s4 = &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, s1.<span class="built_in">size</span>(), s2.<span class="built_in">size</span>(), s3.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用方法：</p>
<ul>
<li><code>size()</code>，$O(1)$</li>
<li><code>clear()</code>，$O(1)$</li>
<li><code>insert(value)</code>，尝试插入一个值，若已存在则忽略，$O(\log_2n)$</li>
<li><code>erase(value)</code>，尝试删除一个值，若不存在则忽略(不会报错)，$O(\log_2 n)$</li>
<li><code>begin()</code> 和 <code>end()</code> 取首尾迭代器，$O(1)$</li>
<li><code>find(value)</code>，查找并返回对应值的迭代器，若不存在则返回 <code>end</code> 迭代器，$O(\log_2n)$</li>
<li><code>lower_bound(value)</code>，查找并返回满足大于等于对应值的最小元素迭代器，不存在返回 <code>end</code>，$O(\log_2n)$</li>
<li><code>upper_bound(value)</code>，查找并返回满足大于对应值的最小元素迭代器，不存在返回 <code>end</code>，$O(\log_2n)$</li>
</ul>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, it == s.<span class="built_in">end</span>()); <span class="comment">//判断是否在s里,与end比较</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = s.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *it2);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    ++it2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *it2);</span><br><span class="line">    s.<span class="built_in">erase</span>(it2);</span><br><span class="line">    <span class="keyword">auto</span> it3= s.<span class="built_in">lower_bound</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *it3);</span><br><span class="line">    <span class="keyword">auto</span> it4 = s.<span class="built_in">upper_bound</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *it4);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有 STL 标准函数并集 set_union、交集 set_intersection 和差集 set_difference，感兴趣自学。</p>
<p>set 的原理是红黑树(一种平衡树)，所以复杂度是 $O(\log_2n)$；下文 map 同理。</p>
<p>注意：使用 STL 函数 <code>lower_bound, upper_bound</code> 作用于 set 和 map 是 $O(n)$，必须使用成员方法才能保证 $O(\log_2n)$</p>
</blockquote>
<h4 id="结构体与逆序"><a href="#结构体与逆序" class="headerlink" title="结构体与逆序"></a>结构体与逆序</h4><p>使用于 set 的结构体，必须重载 <code>&lt;</code> 运算符。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;r) <span class="type">const</span> &#123; <span class="keyword">return</span> i &lt; r.i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;);</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;<span class="number">0</span>, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;&#125;);</span><br><span class="line">    <span class="keyword">auto</span> pr = s.<span class="built_in">begin</span>()-&gt;v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, pr.first, pr.second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆序的话，一种方法是使用 <code>set&lt;类型, greater&lt;类型&gt;&gt;</code>(其他方法与优先级队列类似)，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pr = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;; <span class="comment">//等效于#define pr pair&lt;int,int&gt;是一种偷懒简写</span></span><br><span class="line">set&lt;pr, greater&lt;pr&gt;&gt; s = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, v.first, v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><blockquote>
<p>习惯上可以简称为 <code>unset</code>(语法上不能)。下文 <code>unmap</code> 同理。并不是很常用，但有时候可以使用。</p>
</blockquote>
<p>是无序的集合。无序的优点是性能更高(即上文所有 $O(\log_2n)$ 在这里都是 $O(1)$)(但常数大，故只有在较大数据下如 $10^5$ 或以上，才能显现出来，小数据不如 set)，实现原理是哈希函数(<code>unmap</code> 同理)。</p>
<blockquote>
<p>哈希函数会在后续课程讲解，这里不介绍。</p>
</blockquote>
<p>对结构体，必须重载 <code>==</code> 运算符的数据类型才能使用，且必须重载 <code>()</code> 运算符代表哈希函数，传入参数是该结构体(重载 <code>()</code> 的可以是其他结构体，也可以是自身)。此时格式为 <code>unordered_set&lt;类型, 重载了()的类型&gt;</code>，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> node &amp;r) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x == r.x &amp;&amp; y == r.y &amp;&amp; z == r.z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> node &amp;r)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r.x * <span class="number">1e9</span> + r.y * <span class="number">1e5</span> + r.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">unordered_set&lt;node, node&gt; s2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.<span class="built_in">size</span>());</span><br><span class="line">    s2.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    s2.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    s2.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此外，还有允许重复的多重集 <code>multiset</code> 和同理的 <code>multimap</code>，以及多重无序集，很少用，感兴趣自学。</p>
<p>注意 pair 类型是无法存 unordered_set 的，所以需要给它重载一下或手写 pair。</p>
</blockquote>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>映射，字典。有键和值两个元素。可以理解键是广义数组下标(即从整数拓展到一切数据类型)，值是元素值。所以可以使用 <code>[]</code> 运算符。有序，按照键升序排序。</p>
<p>定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;键数据类型, 值数据类型&gt; 变量名;</span><br></pre></td></tr></table></figure>
<p>常用方法：</p>
<ul>
<li><code>size()</code>，$O(1)$</li>
<li><code>clear()</code>，$O(1)$</li>
<li><code>insert(pair)</code>，插入键值对，若键已存在则忽略(而不是覆盖)，否则插入；$O(\log_2n)$</li>
<li><code>erase(key)</code>，删除，若找得键就删，否则忽略；$O(\log_2 n)$</li>
<li><code>begin()</code> 和 <code>end()</code> 得到迭代器，指向的是 pair；$O(1)$</li>
<li><code>find(key)</code>，查找这个键对应的 pair，不存在返回 <code>end</code> 迭代器；$O(\log_2n)$</li>
<li><code>lower_bound(key)</code>，大于等于该键的迭代器；$O(\log_2n)$</li>
<li><code>upper_bound(key)</code>，大于该键的迭代器；$O(\log_2n)$</li>
<li><code>[key]</code>，取该键对应的值(或赋值)，若不存在马上新建并设值为 0；$O(\log_2n)$</li>
</ul>
<p><code>for-each</code> 遍历时得到的是 pair。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">double</span>, <span class="type">int</span>&gt; m = &#123;&#123;<span class="number">1.1</span>, <span class="number">100</span>&#125;, &#123;<span class="number">2.2</span>, <span class="number">10</span>&#125;, &#123;<span class="number">3.3</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">4.4</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1.1</span>, <span class="number">666</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2lf %d\n&quot;</span>, v.first, v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="number">114514</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m.<span class="built_in">size</span>());</span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="number">1.1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m.<span class="built_in">find</span>(<span class="number">1.1</span>) != m.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> it = m.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf %d\n&quot;</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m.<span class="built_in">lower_bound</span>(<span class="number">2.2</span>)-&gt;second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m.<span class="built_in">upper_bound</span>(<span class="number">2.2</span>)-&gt;second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m[<span class="number">2.2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m[<span class="number">2.3</span>]);</span><br><span class="line">    m[<span class="number">2.4</span>] = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m[<span class="number">2.4</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆序同理，改一下加 <code>greater&lt;键类型&gt;</code> 即可，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m[<span class="number">1437</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    m[<span class="number">580</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pr : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>, pr.first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : pr.second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体同理。只需要键重载了 <code>&lt;</code> 运算符即可。如：(事实上很少键会用结构体)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, v;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node1 &amp;r) <span class="type">const</span> &#123; <span class="keyword">return</span> v &lt; r.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z, w;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;node1, node2&gt; m = &#123;&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;, &#123;&#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> k = i.first;</span><br><span class="line">        <span class="keyword">auto</span> v = i.second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d -&gt; %d %d %d %d\n&quot;</span>, k.i, k.v, v.x, v.y, v.z, v.w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unmap</code> 可以类推得之。可自行尝试，相信不难。</p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>可以认为是静态布尔值数组，但是比一般的布尔值数组快，一般认为快 $32$ 倍，因为原理大约是用一个 int 的 32 位当 32 个 bool 来用。<code>bitset</code> 在后续学到动态规划等地方可能常用，用作优化。如果是 64 位计算机，就快 64 倍。</p>
<p>定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;长度&gt; 变量名; <span class="comment">//一开始全false</span></span><br><span class="line">bitset&lt;长度&gt; 变量名(整型变量); <span class="comment">//将整型转二进制存入(从低到高)</span></span><br><span class="line">bitset&lt;长度&gt; 变量名(只含<span class="number">01</span>的字符串);</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">bitset&lt;10&gt; <span class="title">b1</span><span class="params">(<span class="number">5</span>)</span>, <span class="title">b2</span><span class="params">(<span class="string">&quot;1101&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, b1[<span class="number">3</span>] &amp; <span class="number">1</span>, b1[<span class="number">2</span>] &amp; <span class="number">1</span>, b1[<span class="number">1</span>] &amp; <span class="number">1</span>, b1[<span class="number">0</span>] &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, b2[<span class="number">3</span>] &amp; <span class="number">1</span>, b2[<span class="number">2</span>] &amp; <span class="number">1</span>, b2[<span class="number">1</span>] &amp; <span class="number">1</span>, b2[<span class="number">0</span>] &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接当布尔值数组来用，也有常用方法：一般是 $O(\dfrac nw),w$ 是计算机位数</p>
<ul>
<li>使用位运算符与一个 <code>bitset</code> 直接进行位运算</li>
<li><code>count()</code> 求 1 的个数</li>
<li><code>any()</code> 是否存在 1</li>
<li><code>none()</code> 是否不存在 1</li>
<li><code>set()</code> 全部设为 1</li>
<li><code>reset()</code> 全部设为 0</li>
<li><code>flip()</code> 全部按位取反</li>
</ul>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">bitset&lt;10000&gt; <span class="title">b1</span><span class="params">(<span class="string">&quot;1110&quot;</span>)</span>, <span class="title">b2</span><span class="params">(<span class="string">&quot;1011&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (b1 &amp; b2).<span class="built_in">count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (b1 | b2).<span class="built_in">flip</span>().<span class="built_in">count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (b1 ^ b2)[<span class="number">1</span>] &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充知识：基本位运算(自学，重要)： 与、或、异或、左移与右移</p>
<p>注意要点：</p>
<ul>
<li>优先级： <code>~; +, -; &lt;&lt;, &gt;&gt;; ==, !=; &amp;; ^; |; &amp;&amp;; ||; ?:</code></li>
<li>移位结果为 long long 时应该是 <code>1LL &lt;&lt; k</code></li>
<li>右移位，等同于round(x/2.0)，负数的移位结果不会大于-1</li>
</ul>
<p>常见应用：</p>
<ul>
<li>取正数 <code>x</code> 的从左往右(从零数)第 <code>i</code> 位：<code>(x&gt;&gt;i)&amp;1</code></li>
<li>对某个正数 <code>x</code> 从左往右(从零数)第 <code>k</code> 位修改取反： <code>x^=(1&lt;&lt;k)</code></li>
<li><code>c&amp;15</code>  或 <code>c^&#39;0&#39;</code> 优化 数字字符转数值(手写快读常用)</li>
<li>取某个数的最低 1 所在位(lowbit 操作，后续学树状数组用)： <code>x&amp;-x</code></li>
</ul>
<p>内建函数：</p>
<ul>
<li>注：对 <code>unsigned long long</code> 每个函数名后面加上 <code>ll</code> (传入的是什么类型不影响结果, 影响的是函数名)</li>
</ul>
<p><strong>1.__builtin_popcount(unsigned int n)</strong></p>
<p>该函数时判断n的二进制中有多少个1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">15</span>; <span class="comment">//二进制为1111</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_popcount(n)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出4</span></span><br></pre></td></tr></table></figure>
<p><strong>2.__builtin_parity(unsigned int n)</strong><br>该函数是判断n的二进制中1的个数的奇偶性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">15</span>;<span class="comment">//二进制为1111</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">7</span>;<span class="comment">//111</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_parity(n)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//偶数个，输出0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_parity(m)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//奇数个，输出1</span></span><br></pre></td></tr></table></figure>
<p><strong>3.__builtin_ffs(unsigned int n)</strong><br>该函数判断n的二进制末尾最后一个1的位置，从一开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">8</span>;<span class="comment">//1000</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ffs(n)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ffs(m)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出4</span></span><br></pre></td></tr></table></figure>
<p><strong>4.__builtin_ctz(unsigned int n)</strong><br>该函数判断n的二进制末尾后面0的个数，当n为0时，和n的类型有关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">8</span>;<span class="comment">//1000</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ctzll(n)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ctz(m)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出3</span></span><br></pre></td></tr></table></figure>
<p><strong>5. __builtin_clz (unsigned int x)</strong><br>返回前导的0的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">8</span>; <span class="comment">//1000</span></span><br><span class="line">cout&lt;&lt; <span class="number">32</span> - __builtin_clz(n) &lt;&lt;endl; <span class="comment">//输出1</span></span><br><span class="line">cout&lt;&lt; <span class="number">64</span> - __builtin_clzll(m) &lt;&lt;endl; <span class="comment">//输出4</span></span><br></pre></td></tr></table></figure>
<p>应用：<code>31 - __builtin_clz(n)</code> 等效于 $\lfloor\log_2n\rfloor$ </p>
<p>其他：异或的性质</p>
<ul>
<li><p>交换律、结合律、消去律，有单位元 $0$，自己与自己运算得单位元</p>
</li>
<li><p>$a\oplus b\le a+b=(a|b)+(a\&amp;b)$ </p>
<p>前半句：因异或是不进位的加法；后半句：因 $a\&amp;b$ 是进位部分</p>
</li>
</ul>
</blockquote>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>可变长字符串。默认使用 char 模板，不需要额外指定。只推荐使用一般赋值来初始化。常用方法：</p>
<ul>
<li><p><code>+</code>。字符串拼接。$O(n+m)$</p>
<p>区别：<code>+=</code>，也是拼接，但 $O(m)$</p>
</li>
<li><p><code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>!=</code>，<code>==</code>。字符串字典序比较。$O(\min(n,m))$</p>
</li>
<li><p><code>=</code>。字符串复制，$O(m)$</p>
</li>
<li><p><code>[]</code>。取单个下标的字符的传引用，可以修改。$O(1)$</p>
</li>
<li><p><code>substr(int start[,int len])</code> 取下标范围 $[start,start+len)$ 的子串</p>
<p>如果 $start+len$ 越界，取到结尾为止。若 start 越界报错(<code>erase</code> 同理)。不改变原字符串。$O(len)$</p>
</li>
<li><p><code>back()</code> 取最后一个字符的传引用。$O(1)$</p>
</li>
<li><p><code>insert(int pos, string s)</code> 在下标 <code>pos</code> 处插入字符串 s，原下标 <code>pos</code> 和之后的往后推。改变原字符串。越界会报错。$O(n)$</p>
</li>
<li><p><code>erase(int pos, int len)</code>，删除下标范围 $[start,start+len)$ 的子串，原 $start+len$ 和以后的子串往前挪。$O(n)$</p>
</li>
<li><p><code>find(char/string s, start=0)</code>，在以 $start$ 下标开头的后缀找是否出现过子串 $s$，是返回出现的首字符下标，不出现返回 $-1$。$O(nm)$</p>
<blockquote>
<p>还有 <code>find_first_of</code> , <code>find_last_of</code> , <code>find_first_not_of</code> , <code>find_last_not_of</code>，顾名思义，感兴趣自学</p>
</blockquote>
</li>
<li><p><code>c_str()</code> 取 C 风格字符串。$O(n)$</p>
<p>反过来，C 风格字符串转成 C++ 的 string 直接用 <code>=</code> 即可。</p>
</li>
<li><p><code>begin()</code>, <code>end()</code> 取首尾迭代器，$O(1)$</p>
</li>
</ul>
<blockquote>
<p>虽然有 <code>push_back</code> 函数，但强烈不建议使用，该函数可能引发乱码</p>
</blockquote>
<p>字符串只能用 <code>cin</code> 输入与 <code>cout</code> 输出。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a = <span class="string">&quot;baicha&quot;</span>, b = <span class="string">&quot;guodong&quot;</span>, c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = a + <span class="string">&quot;_xingyue&quot;</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; (a == c) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (a &lt; b) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (a &gt;= b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">3</span>, <span class="number">100</span>) &lt;&lt; b.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="string">&quot;zi&quot;</span>);</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    b.<span class="built_in">erase</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    b.<span class="built_in">back</span>() = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">find</span>(<span class="string">&quot;cha&quot;</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)b.<span class="built_in">find</span>(<span class="string">&#x27;O&#x27;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//区分大小写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; s[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>常用字符串函数：(都是 $O(n)$)</p>
<ul>
<li><code>getline(cin, string)</code>，读整行(与 <code>cin.getline</code> 读 C 风格字符串区分)</li>
<li><code>to_string(any)</code> 将其他类型转化为 <code>string</code>。 注：char 会视为 int。</li>
<li><code>stoi(), stol(), stof(), stod()</code> 将字符串转化为别的类型(分别是 <code>int, long long, float, double</code>)</li>
<li><code>count(首迭代器, 尾迭代器, char)</code> 统计字符出现次数</li>
<li><code>replace(首迭代器, 尾迭代器, char source, char dest)</code> 全部字符替换</li>
</ul>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s, x, y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;a&#x27;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    x = <span class="built_in">to_string</span>(<span class="number">92</span> + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">stoi</span>(x + <span class="string">&quot;86&quot;</span>));</span><br><span class="line">    y = <span class="string">&quot;aaAA&quot;</span>;</span><br><span class="line">    <span class="built_in">replace</span>(y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>(), <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>string 可以进行一系列正则表达式操作，比较少用，感兴趣自学</p>
</blockquote>
<h3 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h3><p>流。一般常用于读取一行(一个字符串)里的内容，即把一个字符串当成要 <code>cin</code> 的对象来处理。</p>
<p>新建流：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringstream 流变量名(字符串变量);</span><br></pre></td></tr></table></figure>
<p>从流里读出一个变量(类比 <code>cin &gt;&gt; 变量名</code>)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流变量名 &gt;&gt; 变量名;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="type">int</span> v, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; v)</span><br><span class="line">    &#123;</span><br><span class="line">        t += v;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>分为编译器函数和库函数。</p>
<p>编译器函数，顾名思义，这些函数不在任何库里，而是编译器自带的。又称内置函数。特征是通常以下划线开头。</p>
<blockquote>
<p>上文提到的位运算函数都是编译器函数。</p>
</blockquote>
<p>此外，还有：常用的是 <code>__gcd(a, b)</code>，显然就是求两个整数的最大公因数。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, __gcd((<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>), <span class="number">998244353</span>)); <span class="comment">//两个常见质数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, __gcd(<span class="number">30</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, __gcd(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">//(0,x)=x</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不建议对一正一负使用 <code>__gcd</code>，结果正负号无规律。若同为负，则有 $\gcd(x,y)=-\gcd(-x,-y)$。 $O(\log\max(a,b))$</p>
<p>常用库函数有：</p>
<ul>
<li><p><code>max(v1, v2)</code> 返回较大值；多个值就 <code>max(&#123;v1, v2, ..., vn&#125;)</code>；同理有 <code>min</code> 函数。$O(|v|)$(即参数数目)</p>
</li>
<li><p><code>sort(首迭代器, 尾迭代器[,比较函数])</code> 排序 ，$O(n\log n)$，原理是内省排序(快排+堆排+插排)</p>
</li>
<li><p><code>unique(首迭代器, 尾迭代器)</code>。对升序序列去重，返回去重后不重部分长度，$O(n)$</p>
</li>
<li><p><code>reverse(首, 尾)</code>。转置一个序列，$O(n)$</p>
</li>
<li><p><code>inplace_merge(l, c, r[, 比较函数])</code>，合并一个序列的两个连续升序部分 $[l,c)$, $[c,r)$ 为一个升序序列 $[l,r)$</p>
<p><code>merge(首1, 尾1, 首2, 尾2, 目标迭代器[, 比较函数])</code>，合并两个升序序列到目标迭代器上，均 $O(n)$</p>
<blockquote>
<p>在后续课程的归并排序中可以使用到</p>
</blockquote>
</li>
<li><p><code>lower_bound(首, 尾, 值)</code>，找升序序列首个大于等于值的迭代器所在，查无返回尾迭代器，$O(\log_2 n)$</p>
<p><code>upper_bound(首, 尾, 值)</code>，找升序序列首个大于值的迭代器所在，查无返回尾迭代器，$O(\log_2 n)$</p>
<p><code>lower_bound(首, 尾, 值, greater&lt;类型&gt;())</code>，找降序序列首个小于等于值的迭代器所在，查无返回尾迭代器，$O(\log_2 n)$</p>
<p><code>upper_bound(首, 尾, 值, greater&lt;类型&gt;())</code>，找降序序列首个小于值的迭代器所在，查无返回尾迭代器，$O(\log_2 n)$</p>
<blockquote>
<p>在后续课程的二分算法广泛使用；请注意用这些函数直接操作 set/map 的复杂度是 $O(n)$ 的，而使用 set/map 的同名方法才是 $O(\log_2n)$ 的</p>
</blockquote>
</li>
</ul>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="type">int</span> c1[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, c2[] = &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, c3[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a, a + <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">print</span>(a, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">print</span>(a, <span class="number">7</span>);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">unique</span>(a, a + <span class="number">7</span>) - a;</span><br><span class="line">    <span class="built_in">print</span>(a, n2);</span><br><span class="line">    <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(a, a + n2, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pos);</span><br><span class="line">    <span class="built_in">inplace_merge</span>(b, b + <span class="number">4</span>, b + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">print</span>(b, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">merge</span>(c1, c1 + <span class="number">3</span>, c2, c2 + <span class="number">2</span>, c3);</span><br><span class="line">    <span class="built_in">print</span>(c3, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一些不常用的，如 <code>nth_element, advance, max_element</code>。感兴趣自行学习。</p>
<p>生成随机数，可以自行去了解 <code>mt19937</code> 数据类型等，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc(x) scanf(<span class="string">&quot;%lld&quot;</span>, &amp;x)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">random_device divc;</span><br><span class="line"><span class="function">mt19937 <span class="title">mt</span><span class="params">(divc())</span></span>;</span><br><span class="line"><span class="function">uniform_int_distribution&lt;ll&gt; <span class="title">range1</span><span class="params">(<span class="number">1</span>, <span class="number">10000000</span>)</span></span>;</span><br><span class="line">ll a, b;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// SCNUOJ1001</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">sc</span>(a), <span class="built_in">sc</span>(b);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     ll c = <span class="built_in">range1</span>(mt);</span><br><span class="line">     <span class="keyword">if</span> (a + b == c)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, c);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc(x) scanf(<span class="string">&quot;%lld&quot;</span>, &amp;x)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll v[<span class="number">5050</span>], n = <span class="number">10</span>, a, b;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> random_device rd;</span><br><span class="line"> <span class="function">mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">     v[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">shuffle</span>(v + <span class="number">1</span>, v + <span class="number">1</span> + n, mt);</span><br><span class="line"> <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, v[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2022年10月31日 18:58</p>
        <p>原始链接： <a class="post-url" href="/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/" title="cpp入门-课件">https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/</a></p>
        <footer>
            <a href="https://lr580.github.io">
                <img src="/images/logo.png" alt="lr580">
                lr580
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/&title=《cpp入门-课件》 — lr580's blog&pic=https://lr580.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/&title=《cpp入门-课件》 — lr580's blog&source=QwQ" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《cpp入门-课件》 — lr580's blog&url=https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/&via=https://lr580.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://lr580.github.io/2022/10/31/cpp%E5%85%A5%E9%97%A8-%E8%AF%BE%E4%BB%B6/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/md/" class="color3">md</a>
      
    <a href="/tags/香农先修班/" class="color1">香农先修班</a>
      
    <a href="/tags/算法/" class="color3">算法</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2022-%E9%A6%99%E5%86%9C%E5%85%88%E4%BF%AE%E7%8F%AD%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%BE"><span class="post-toc-text">2022 香农先修班第一次课</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="post-toc-text">语法基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post-toc-text">基本概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="post-toc-text">万能头文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="post-toc-text">命名空间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="post-toc-text">输入输出</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%85%A5"><span class="post-toc-text">输入</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#cin"><span class="post-toc-text">cin</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#getline"><span class="post-toc-text">getline</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA"><span class="post-toc-text">输出</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%BB%E5%86%99%E5%8A%A0%E9%80%9F"><span class="post-toc-text">读写加速</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="post-toc-text">传引用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-text">结构体</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="post-toc-text">基本使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95"><span class="post-toc-text">方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">重载运算符</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#auto"><span class="post-toc-text">auto</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for-each"><span class="post-toc-text">for-each</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="post-toc-text">匿名函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="post-toc-text">模板类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#STL"><span class="post-toc-text">STL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector"><span class="post-toc-text">vector</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="post-toc-text">定义和使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-text">常用方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B5%8C%E5%A5%97"><span class="post-toc-text">嵌套</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pair"><span class="post-toc-text">pair</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#tuple"><span class="post-toc-text">tuple</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stack"><span class="post-toc-text">stack</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#queue"><span class="post-toc-text">queue</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#priority-queue"><span class="post-toc-text">priority_queue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1"><span class="post-toc-text">基本使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="post-toc-text">结构体</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%80%86%E5%BA%8F"><span class="post-toc-text">逆序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#set"><span class="post-toc-text">set</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2"><span class="post-toc-text">基本使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%80%86%E5%BA%8F"><span class="post-toc-text">结构体与逆序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#unordered-set"><span class="post-toc-text">unordered_set</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#map"><span class="post-toc-text">map</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bitset"><span class="post-toc-text">bitset</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#string"><span class="post-toc-text">string</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stringstream"><span class="post-toc-text">stringstream</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="post-toc-text">常用函数</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2022/10/31/ACM%E9%9B%86%E8%AE%AD%E9%98%9F%E5%88%86%E4%BA%AB%E4%BC%9A-%E9%87%8D%E7%8E%B0/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          ACM集训队分享会-重现
        
      </span>
    </a>
  
  
    <a href="/2022/06/30/%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">个人服务器搭建过程</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
	
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk-container"></div> <!--评论区实际地方-->
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var id = md5(window.location.pathname) //怕太长了
    var gitalk = new Gitalk({
        clientID: '6e8ca84614e8d6de868c',
        clientSecret: 'bd819b13650d089fa5e4708a9a5cd16bb122206d',
        id: id,
        repo: 'lr580.github.io',
        owner: 'lr580',
        admin: [''], 
        labels: 'gitalk'.split(',').filter(l => l),
        perPage: 15,
    	pagerDirection: 'last',
		language: 'zh-CN',
    })
    gitalk.render('gitalk-container')
	//document.write(id) //调试输出
</script>


    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2024 lr580<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://lr580.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ACM/" style="font-size: 12px;">ACM</a> <a href="/tags/MUPAD/" style="font-size: 10px;">MUPAD</a> <a href="/tags/SP/" style="font-size: 10px;">SP</a> <a href="/tags/md/" style="font-size: 16px;">md</a> <a href="/tags/%E5%88%86%E4%BA%AB/" style="font-size: 20px;">分享</a> <a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 12px;">小说</a> <a href="/tags/%E5%BF%83%E5%BE%97/" style="font-size: 14px;">心得</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size: 10px;">心理学</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">笔记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18px;">算法</a> <a href="/tags/%E8%85%90%E7%AB%B9%E6%B8%85%E6%B1%A4/" style="font-size: 12px;">腐竹清汤</a> <a href="/tags/%E8%B5%84%E6%BA%90/" style="font-size: 18px;">资源</a> <a href="/tags/%E9%A6%99%E5%86%9C%E5%85%88%E4%BF%AE%E7%8F%AD/" style="font-size: 16px;">香农先修班</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ACM/" style="font-size: 12px;">ACM</a> <a href="/tags/MUPAD/" style="font-size: 10px;">MUPAD</a> <a href="/tags/SP/" style="font-size: 10px;">SP</a> <a href="/tags/md/" style="font-size: 16px;">md</a> <a href="/tags/%E5%88%86%E4%BA%AB/" style="font-size: 20px;">分享</a> <a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 12px;">小说</a> <a href="/tags/%E5%BF%83%E5%BE%97/" style="font-size: 14px;">心得</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size: 10px;">心理学</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">笔记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18px;">算法</a> <a href="/tags/%E8%85%90%E7%AB%B9%E6%B8%85%E6%B1%A4/" style="font-size: 12px;">腐竹清汤</a> <a href="/tags/%E8%B5%84%E6%BA%90/" style="font-size: 18px;">资源</a> <a href="/tags/%E9%A6%99%E5%86%9C%E5%85%88%E4%BF%AE%E7%8F%AD/" style="font-size: 16px;">香农先修班</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [ ["$","$"], ["\\(","\\)"] ], skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], processEscapes: true } }); MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(); for (var i = 0;
    i
    < all.length; ++i) all[i].SourceElement().parentNode.className +=' has-jax' ; }); </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML
"></script>
</body>
</html>