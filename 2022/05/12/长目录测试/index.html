<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>长目录测试 | lr580&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="lr580,lr580's Blog" />
  
  <meta name="description" content="打开mupad: 方法一：打开matlab(最新版本不支持)，输入mupad 方法二：打开matlab(最新版本不支持)，输入mupadwelcome,打开new notebook  语法基本语法运算符按照优先级排序，不同优先级换行表示 &#39; 求导 [] 下标从1开始 @@ 函数迭代(?) @ 函数复合(?) ! 阶乘; !! 双阶乘，如3!!&#x3D;3,4!!&#x3D;8,3!!!&#x3D;(3!!)!&#x3D;3!">
<meta property="og:type" content="article">
<meta property="og:title" content="长目录测试">
<meta property="og:url" content="https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="lr580&#39;s blog">
<meta property="og:description" content="打开mupad: 方法一：打开matlab(最新版本不支持)，输入mupad 方法二：打开matlab(最新版本不支持)，输入mupadwelcome,打开new notebook  语法基本语法运算符按照优先级排序，不同优先级换行表示 &#39; 求导 [] 下标从1开始 @@ 函数迭代(?) @ 函数复合(?) ! 阶乘; !! 双阶乘，如3!!&#x3D;3,4!!&#x3D;8,3!!!&#x3D;(3!!)!&#x3D;3!">
<meta property="og:locale">
<meta property="article:published_time" content="2022-05-12T08:46:02.000Z">
<meta property="article:modified_time" content="2022-05-12T08:49:09.138Z">
<meta property="article:author" content="lr580">
<meta property="article:tag" content="md">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">lr580&#39;s 博客</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        lr580&#39;s 博客
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        建设期，不定期更新。
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Github" target="_blank" href="//github.com/lr580">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="2277379149"  ">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                        <a title="洛谷博客" target="_blank" href="//lr580.blog.luogu.org">
                            <i class="fa fa-user-o fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-长目录测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      长目录测试
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2022-05-12
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <blockquote>
<p><strong>打开mupad:</strong></p>
<p>方法一：打开matlab(最新版本不支持)，输入mupad</p>
<p>方法二：打开matlab(最新版本不支持)，输入mupadwelcome,打开new notebook</p>
</blockquote>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>按照优先级排序，不同优先级换行表示</p>
<pre><code class="lang-matlab">&#39; 求导
[] 下标从1开始
@@ 函数迭代(?)
@ 函数复合(?)
! 阶乘; !! 双阶乘，如3!!=3,4!!=8,3!!!=(3!!)!=3!=6
^ 幂，如2^3+1=9 注意优先级，如2^(3^4)代表2^81，否则从左往右
*/
- 负号
+-
div 地板除;mod 取模  3 div 2 = 1 //注意空格
... 浮点数闭区间(?)
intersect 交集(?)
minus 差集(?)
union 并集(?)
.. 取值范围
= ~= &lt;&gt; &lt; &gt; &lt;= &gt;= in subset   第二个是约等于，subset是子集(?)
$ 创建序列
not
and 
xor 逻辑异或(?)
or assuming 局部假设(?)
==&gt; 逻辑蕴含(?)
&lt;=&gt; 逻辑等价(?)
| 函数在某点取值(?)
</code></pre>
<pre><code class="lang-matlab">: 不显示结果的命令语句结束符
; 显示结果的命令语句结束符(默认)
:= 赋值
% 倒数第一个计算结果
%n 倒数第n个计算结果
// /* */ 代码注释，如z:=1/*123*/+2;
</code></pre>
<pre><code class="lang-matlab">-&gt; 映射而不计算
--&gt; 映射并计算
&#123;&#125; 生成集合(也可以用下标)
\ 续行 系统设置输出区域每一行的最大字符个数的默认值为80，大于时续行
</code></pre>
<p>保留字：</p>
<pre><code class="lang-matlab">D 值域
E e
I i
O 上界
</code></pre>
<h3 id="基本数学函数"><a href="#基本数学函数" class="headerlink" title="基本数学函数"></a>基本数学函数</h3><pre><code class="lang-matlab">exp(x) 即E^x
ln(x) log10(x) log2(x) 自然对数函数
log(底, x) log(2,8)=3
sqrt(x) 开方 surd(x,n) 开n次方 会化简，而^运算符不会
max(可变参数) min(...) 最值
ceil floor round trunc 取整
sign abs 符号函数，绝对值函数
Re(x) Im(x) 取实数实部和虚部
arg(x) 复数辐角，范围(-PI,PI]
sin cos tan cot arc-... 三角和反三角
sinh cosh tanh coth 和arc-... 双曲和反双曲
</code></pre>
<h4 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h4><h5 id="round"><a href="#round" class="headerlink" title="round"></a>round</h5><p>round(x)或round(x,n)四舍五入并保留n为小数</p>
<p>注意，对于分数，一定是准确的，但对于小数的0.5，有如下特性：</p>
<pre><code class="lang-matlab">i+0.5$i=-4..6 
= -3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5 
round(i+0.5)$i=-4..6
= -4, -2, -2, 0, 0, 2, 2, 4, 4, 6, 6
</code></pre>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre><code class="lang-matlab">delete 清除标识符 删除一个或多个(逗号分隔) 不进行输出故;:等效
    delete可以避免要用一个变量建立表达式，但它是程序意义上的变量而进行替代
domtype type 查看数据类型(略有区别，一般用前者)
float 计算近似值
</code></pre>
<pre><code class="lang-matlab">hold() 不计算内部的内容，用于积分或只显示(数学格式)
</code></pre>
<pre><code class="lang-matlab">assuming 逻辑条件  为当前计算设置前置条件
assume(条件) 为所有计算设置前置条件
</code></pre>
<pre><code class="lang-matlab">numer(f) 返回分子
denom(f) 返回分母
</code></pre>
<h3 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h3><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>可以不使用print，直接使用x;x为可打印变量；或赋值时开启;而不是使用:</p>
<p>在循环控制结构，应该使用print语句，使用后穿透end_for的:，且不会与原有的;型输出重复输出。</p>
<p>print():与print();效果相同；在一般顺次结构里，不会影响上一次的输出</p>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>格式有：</p>
<pre><code class="lang-matlab">if 表达式 then
    代码
else
    代码
end_if;//;或:控制是否进行输出(多行只输出最后一次无论其本身:/;)
</code></pre>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre><code class="lang-matlab">for i from v1 to v2 do
    代码
end_for:
</code></pre>
<p>举例：</p>
<pre><code class="lang-matlab">delete x,y;
x:=0:
y:=0:
for i from 1 to 10 do
x:=x+i;//记得分号(代码块的最后一行可以不)
y:=y+i*i;//只输出y的最后一次
end_for;//若改为:，一次也不输出
</code></pre>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code class="lang-matlab">PI，E 常量  I 虚数单位
infinity -infinity Left Right 常量
TRUE FALSE UNKNOWN 逻辑常量
</code></pre>
<pre><code class="lang-matlab">N_ 自然数集
R_ 实数集
C_ 复数集
</code></pre>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><h5 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h5><pre><code class="lang-matlab">DIGITS 10 十进制有效小数位数，注意是有效小数位数，而不是小数位数
</code></pre>
<p>对于带有小数点的十进制数，如果为$a_m$非零数字，则称$0.00a_ma_{m+1} \dots a_{m+k-1}a_{m+k}$具有k位有效数字</p>
<p>超出有效小数部分会丢失，除非重改该常量，可提高计算精度。</p>
<blockquote>
<p>如果DIGITS&lt;=9,10^-10^的浮点数都是1.0e-10，精确值，科学计数法</p>
<p>如果&gt;=10,都是0.0000000001，精确值</p>
<p>如果DIGITS&lt;=15,2^-52^的浮点数都采用科学计数法，，尾数部分显示给定位数的有效数字，近似值</p>
<p>如果16&lt;=DIGITS&lt;=36，都采用小数，显示给定位数的有效数字，近似值</p>
<p>如&gt;=37，采用小数，精确值(因为够位置显示了)</p>
<p>即规律为：如果已经有足够的位数显示所有，就精确，否则科学/近似 </p>
<p>EPS为2^-52^ 约为2e-16</p>
</blockquote>
<p>否则：1^20^+5=1^20^，1+1^-99^=1</p>
<h3 id="输出与文本"><a href="#输出与文本" class="headerlink" title="输出与文本"></a>输出与文本</h3><h4 id="输出方法"><a href="#输出方法" class="headerlink" title="输出方法"></a>输出方法</h4><p>使用逗号间隔或作行末，最后使用分号，同一行内输出多个运算结果</p>
<p>使用冒号结尾，不输出运算结果</p>
<p>使用print输出，必然输出运算结果。</p>
<h4 id="输出区域格式"><a href="#输出区域格式" class="headerlink" title="输出区域格式"></a>输出区域格式</h4><p>在Notebook处较下方</p>
<h5 id="Typeset-Math"><a href="#Typeset-Math" class="headerlink" title="Typeset Math"></a>Typeset Math</h5><p>标准的印刷体数学符号(图片型/latex型)</p>
<h5 id="Abbreviate-Output"><a href="#Abbreviate-Output" class="headerlink" title="Abbreviate Output"></a>Abbreviate Output</h5><p>仅在Typeset Math下有效，显示缩写</p>
<h5 id="Pretty-Print"><a href="#Pretty-Print" class="headerlink" title="Pretty Print"></a>Pretty Print</h5><p>用纯文本模拟数学公式</p>
<blockquote>
<p>将输出的任意内容复制到代码框，会得到一般纯文本(即输入的代码)</p>
</blockquote>
<p>都不勾选就是一般的代码</p>
<h4 id="下标输出"><a href="#下标输出" class="headerlink" title="下标输出"></a>下标输出</h4><p>一个下划线对应右边1个字符，不能再多；没有下标嵌套</p>
<p>例如xyz_n3_m1为$xyz_n3_m1$</p>
<p>如果需要使用变量下标，应当用.号：</p>
<pre><code class="lang-matlab">delete x_,n;
x_.1;
x_.n;
x_.1^2+x_.n^2;
x_.i $ i=1..3;//[1,3]闭区间
x_.&#123;i&#125; $ i=-10..15 step 5;
x_.i._.j $ j=1..3 $ i=1..3;//相当于内层j外层i
</code></pre>
<h3 id="精确值"><a href="#精确值" class="headerlink" title="精确值"></a>精确值</h3><p>小数都是不精确的，分数可以符号运算</p>
<pre><code class="lang-matlab">0.5+1/2 = 1.0
1/2+1/2 = 1
56^(1/2)=sqrt(56)(未化简)
56^0.5=7.483314774
</code></pre>
<h3 id="特殊文本"><a href="#特殊文本" class="headerlink" title="特殊文本"></a>特殊文本</h3><blockquote>
<p>还有更多在课件里找到复制到命令行就可以看到源码了</p>
</blockquote>
<p>偏导数：</p>
<pre><code class="lang-matlab">output::mathText(`&amp;PartialD;`,u)/output::mathText(`&amp;PartialD;`, x)
</code></pre>
<p>单位方向：</p>
<pre><code class="lang-matlab">matrix([[`i&amp;rarr;`, `j&amp;rarr;`, `k&amp;rarr;`]])
</code></pre>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><p>略(实数R、复数C、布尔值、表达式、函数等)</p>
<h3 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>DOM_LIST</p>
<blockquote>
<p>帮助文档的Lists</p>
</blockquote>
<pre><code class="lang-matlab">a:=[[1,2],[3,4]]:
b:=[];//空列表
</code></pre>
<p>下标：以1开始，可以反着来，如-2代表倒数第二个</p>
<p>可以进行列表加法，乘法(一一对应组合)，幂(同理)</p>
<p>列表可以同常数进行加法、乘法、幂操作</p>
<p>列表可以插入一个或多个元素，使用下面两种方法之一：</p>
<pre><code class="lang-matlab">lt:=[a,b,c]:
lt2:=append(lt,d,e);//lt不变；如果是让lt真正插入，lt2改lt
</code></pre>
<pre><code class="lang-matlab">lt:=[a,b,c]:
lt:=lt.[d,e];//连接运算符
</code></pre>
<p>删除某个元素，使用delete lt[下标]</p>
<p>可以用sort()函数升序排序</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>DOM_SET</p>
<blockquote>
<p>题目要求生成集合就加一个大括号</p>
</blockquote>
<pre><code class="lang-matlab">a:=&#123;x+y=1,x-y=3&#125;:
</code></pre>
<p>自然有数学集合的特性，元素不能重复。列表转集合可以去重，方法：</p>
<pre><code class="lang-matlab">unique_c = &#123;c&#125;;//c是列表
</code></pre>
<p>默认升序排序</p>
<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><pre><code class="lang-matlab">a:=$1..9; //公差1首项1项数9等比数列
b:=k $ k=9..1 step -1//公差-1，余同上
c:=sin(k*PI/n) $ k=0..n;
x$5 五个重复的x
i^2$i in [1,3,-2] //集合也可
</code></pre>
<h2 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h2><h3 id="表达式变换"><a href="#表达式变换" class="headerlink" title="表达式变换"></a>表达式变换</h3><h4 id="代值"><a href="#代值" class="headerlink" title="代值"></a>代值</h4><h5 id="subs"><a href="#subs" class="headerlink" title="subs"></a>subs</h5><pre><code class="lang-matlab">delete a,b,c,x;
f:=a+b+c:
subs(f,[a=x^2,c=5]);
</code></pre>
<p>不会改变f</p>
<p>subs执行的类似于宏替代</p>
<h5 id="subsex"><a href="#subsex" class="headerlink" title="subsex"></a>subsex</h5><p>同subs,但可以代入表达式，而不是死板类似宏替代</p>
<pre><code class="lang-matlab">delete a,b,c,x;
f:=a+b+c:
subsex(f,a+c=x^2+5);
</code></pre>
<h4 id="常态"><a href="#常态" class="headerlink" title="常态"></a>常态</h4><p>normal(表达式)</p>
<p>分式会通分，用因式分解合并分母(但不拆，保留积的形式)，分子也会因式分解；但normal分解因式不彻底</p>
<h4 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h4><p>传入的值可以是一个表达式，或多个表达式的列表/集合</p>
<h5 id="simplify"><a href="#simplify" class="headerlink" title="simplify"></a>simplify</h5><ul>
<li>对三角函数的化简不是最简的</li>
<li>对根式化简，提取公因式，可能不提取分母</li>
</ul>
<h5 id="Simplify"><a href="#Simplify" class="headerlink" title="Simplify"></a>Simplify</h5><ul>
<li>三角函数化简到最简</li>
<li>对根式化简，提取公因式；也会提取分母</li>
</ul>
<h5 id="radsimp"><a href="#radsimp" class="headerlink" title="radsimp"></a>radsimp</h5><p>根式化简，不提取公因式</p>
<blockquote>
<p>先expand后化简和直接化简对三角函数产生的结果可能不一致；expand后更可能元会变大，如从x到2x乃至4x</p>
</blockquote>
<h5 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h5><p>通分</p>
<pre><code class="lang-matlab">normal(11/33)
</code></pre>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><p>合并同类项，用法：collect(表达式,变元)</p>
<pre><code class="lang-matlab">delete x,y,z;
p:=x*y^4+x*z+2*x^3+x^2*y*z+3*x^3*y^4*z^2+y*z^2+5*x*y*z;
collect(p,x);
</code></pre>
<p>分式会对分子分母都做</p>
<p>获得变元的N次多项式。如果变元有多个，使用列表，排序顺序按列表顺序，具体为：</p>
<ol>
<li>有前者优先</li>
<li>都有前者，次数大优先</li>
</ol>
<p>对[z,x]举例(忽略系数)：$先后为：z^2x^3 \to z^2 \to zx^2 \to zx \to x^3 \to x$</p>
<blockquote>
<p>用sincos合并sin(x)+cos(x)会得到cos的改写，<br>但S/simplify会写成sin</p>
</blockquote>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><h5 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h5><p>rewrite(f,g)用g重写f，例如：</p>
<pre><code class="lang-matlab">delete x:
rewrite(tanh(x),exp);
rewrite(arcsinh(x),exp);
rewrite(exp(x),sinhcosh);//sinh,cosh
rewrite(exp(x),tanh);
rewrite(beta(x,y),fact);
</code></pre>
<h4 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h4><h5 id="factor"><a href="#factor" class="headerlink" title="factor"></a>factor</h5><p>命令factor计算多项式的因式分解，返回不可约因式的乘积</p>
<p>也可以进行数的幂归并或质因数分解。</p>
<p>factor(f)<br>factor(f, Full, MaxDegree=n)<br>factor(f, Adjoin=[k_1,k_2,…],MaxDegree=n)<br>factor(f,R_ )<br>factor(f,C_)</p>
<blockquote>
<p>​        如果多项式f的系数都是有理数，factor(f)就返回f在有理数域内的全部不可约因式的乘积的符号表达式；<br>​        如果f的系数含有浮点小数，factor(f)就返回f在实数域内的全部不可约因式的乘积，但是所有系数以及f的全部实数根<br>​        都输出成浮点数值（包括精确值和近似值）；<br>factor(f, Full, MaxDegree=n)返回多项式 f 在复数域内的不可约因式分解（一次因式及其乘幂）的符号精确解，<br>​        选项MaxDegree=n是符号解当中所用到的正整数次方根的最高次数（显然正整数 n 的最小值是2，因为不存在一次方根），系统的默认值是MaxDegree=2，即符号解只用到平方根。在代数学理论上已经知道五次及五次以上的一元代数方程没有一般的求根公式</p>
</blockquote>
<pre><code class="lang-matlab">delete x;
f:=(x^2+x+2)^2*(x^3+1)*(x^3-2*x-1);
factor(f);
factor(f, Full);//展开二次、三次等到复数集，如(x^2+x+x)^2展开在复数域的不可约因式分解的符号精确解；根式、复数都展开
factor(f, Adjoin=[sqrt(5)]);//实数域的不可约因式分解的符号精确解：展开根式而不展开复数
factor(f, R_);//展开根式并根式转float，不展开复数
</code></pre>
<pre><code class="lang-matlab">factor(205891132094649/1073741824)
factor(992)
</code></pre>
<h5 id="partfrac"><a href="#partfrac" class="headerlink" title="partfrac"></a>partfrac</h5><p>partfrac(f,x)<br>partfrac(f,x,Adjoin=[k_1,k_2,…])<br>partfrac(f,x,Domain=R_)</p>
<pre><code class="lang-matlab">partfrac(1/f);//展开为分式
partfrac(1/f, Adjoin=[sqrt(5)]);//+分解
partfrac(1/f, Domain=R_);//分解为float
</code></pre>
<p>有理函数展开</p>
<pre><code class="lang-matlab">delete a,b,c,d,e,x;
P:=2-2*x;
Q:=x^5+x^4+2*x^3+2*x^2+x+1;
partfrac(P/Q);
</code></pre>
<pre><code class="lang-matlab">//也可以用换元法
R:=a/(x+1)+(b*x+c)/(x^2+1)+(d*x+e)/(x^2+1)^2:
f:=collect(numer(normal(R)), x);
eqs:=coeff(f-P,[x]);//从最高次项至0提取系数(无则跳过)
S:=solve([eqs], [a,b,c,d,e]);
subs(R, S[1]); //与上面结果一致
</code></pre>
<p>计算有理函数积分：</p>
<pre><code class="lang-matlab">delete x;
//int(x^7/(x^3+1), x);
partfrac(x^7/(x^3+1));
int(x^4-x, x) - int(1/(3*(x+1)), x) +int((x/3+1/3)/(x^2-x+1), x);
</code></pre>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>numer(f) 返回分子<br>denom(f) 返回分母<br>normal(f)把相除之后的真数通分<br>coeff(f)提取单变量多项式的系数(按系数降序，若无系数跳过该项)<br>    coeff(f,[x])以x为变元提取系数</p>
<pre><code class="lang-matlab">subs(-(t*(t^4+3)^(1/2))/3, t=((x+1)/(x-1))^(1/2));
normal(%) assuming x&gt;1;
</code></pre>
<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><p>sum(表达式, 求和范围) 返回符号解</p>
<p>numeric::sum(同上) 则返回数值解(默认十位小数)</p>
<pre><code class="lang-matlab">sum(i,i=1..10);
delete i,n;
sum(i^3,i=1..n);
</code></pre>
<pre><code class="lang-matlab">delete j,k,n,t;
v:=t-&gt;160-9.8*t:
sum(v((k-1)*(3/n))*(3/n), k=1..n);
Simplify(%);
limit(%, n=infinity);
</code></pre>
<p>product求积</p>
<pre><code class="lang-matlab">product(i,i=3..5)
</code></pre>
<h3 id="方程"><a href="#方程" class="headerlink" title="方程"></a>方程</h3><h4 id="方程的写法"><a href="#方程的写法" class="headerlink" title="方程的写法"></a>方程的写法</h4><h5 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h5><ul>
<li>一个表达式，如x^2^+1</li>
<li>(推荐)映射g:=x-&gt;x+1, g:=(x,y)-&gt;x^2^+y^3^，如果需要计算导数等，—&gt;</li>
<li>分段函数piecewise</li>
<li>复合函数f(g(x))可以写作f@g</li>
</ul>
<h5 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h5><p>piecewise</p>
<pre><code class="lang-matlab">delete f,x,pw;
f:=x-&gt;piecewise([x&lt;0 or x &gt;1,0],[x&gt;=0 and x&lt;=1,1])
pw:=x-&gt;piecewise([x&gt;0 and x &lt; 1,1],[Otherwise,0]);
</code></pre>
<p>举例：</p>
<pre><code class="lang-matlab">h:=t--&gt;int(v(s), s=0..t);//可以计算用--&gt;
h&#39;(t);

f:=x--&gt;x^2:
g:=x--&gt;sin(x):
(g@f)(2)

f:=(x,y)--&gt;x*x*y/(x*x+y*y):
</code></pre>
<p>在绘图时，可以用Otherwise和undefined来让一些不想要绘图的地方不画：</p>
<pre><code class="lang-matlab">delete x,y,z:
h1:=(x,y)-&gt;piecewise([x^3&lt;=y&lt;=sqrt(x), 0], [Otherwise, undefined]):
h2:=(x,y)-&gt;piecewise([x^3&lt;=y&lt;=sqrt(x), 1+x^2+y^2], [Otherwise, undefined]):
f:=(y,z)-&gt;piecewise([z&lt;=1+y^4+y^2, z], [Otherwise, undefined]):
g:=(x,z)-&gt;piecewise([z&lt;=1+x^2+x^6, z], [Otherwise, undefined]):
S1:=plot::Function3d(h1(x,y), x=0..1, y=0..1):
S2:=plot::Function3d(h2(x,y), x=0..1, y=0..1):
S3:=plot::Surface([y^2, y, f(y,z)], y=0..1, z=0..3, Color=RGB::Green):
S4:=plot::Surface([x, x^3, g(x,z)], x=0..1, z=0..3, Color=RGB::Blue):
plot(S1, S2, S3, S4);
</code></pre>
<h4 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h4><p>solve</p>
<pre><code class="lang-matlab">solve(方程,自变量,MaxDegree=最高次)
可以加上Real表示在实数范围内求解
</code></pre>
<pre><code class="lang-matlab">delete x:
solve(x^3 + x^2 + 1 = 0, x, MaxDegree = 3);//=0可以省略
solve(a*x^2+b*x+c,x);
</code></pre>
<pre><code class="lang-matlab">delete x,y;
solve(&#123;x+y=1,x-y=3&#125;,&#123;x,y&#125;);//方括号也行
</code></pre>
<p>参数不够也能解，未知参数会保留：</p>
<pre><code class="lang-matlab">solve([x-y+2*z=6, 2*x+y+z=5], [x,y,z]);
</code></pre>
<pre><code class="lang-matlab">solve(x^2=-1);
solve(x^2=-1,Real);//无解,输出空集
solve((1/(n+1)^2-0)&lt;epsilon,n,Real)assuming n &gt; 0;
</code></pre>
<p>使用assuming限定范围：</p>
<pre><code class="lang-matlab">delete x,a,b,c:
solve(a*x^2+b*x+c,x) assuming a&lt;&gt;0;
</code></pre>
<blockquote>
<p>待解决:纯虚数等值域问题</p>
</blockquote>
<p>MaxDegree开得小将不能求解三次方根，三次方根必须开MaxDegree求解：</p>
<pre><code class="lang-matlab">delete a,b,c;
solve(a*x^3+b*x^2+c*x+d=0,x,MaxDegree=3)
</code></pre>
<p>但是即便开了MaxDegree，最高只能求4次方程的通解或特解。</p>
<p>如果只需要某个方程的数值解而不是符号解，应当使用numeric::solve，当然这个是可以算五次方或以上的，而且不用开MaxDegree。</p>
<pre><code class="lang-matlab">numeric::solve(13*x^4+2*x^3+5*x^2-7*x+16=0,x);
</code></pre>
<p>低次时，float(solve(..))即可得到某个特解的数值解。</p>
<blockquote>
<p>语法格式为：</p>
<p>(1) numeric::solve(eqs, vars, options)</p>
<p>说明：</p>
<p>eqs：只求解一个方程时，eqs指代方程的表达式；求解方程组时，eqs指代若干个方程表达式的集合</p>
<p>（DOM_SET类型，用一对花括号括住若干个方程表达式）或者列表（DOM_LIST类型，用一对方括号括住若干个方程表达式）；</p>
<p>vars：只有一个未知数时，vars指代未知数的标识符；有多个未知数时，vars指代若干个未知数的标识符的集合</p>
<p>（DOM_SET类型，用一对花括号括住若干个方程表达式）或者列表（DOM_LIST类型，用一对方括号括住若干个方程表达式）；一般而言，未知数的个数等于方程的个数；eqs与vars的类型须一致；</p>
<p>options：可选项，本次实验需要用到AllRealRoots，用于求出方程（一个未知数）的全部实根的数值解.</p>
<p>(2) numeric::solve(eq, var=a)    返回方程（一个未知数）在数值a附近的一个数值解.</p>
<p>(3) numeric::solve(eq, var=a..b)    返回方程（一个未知数）在区间[a, b]范围内的一个数值解.</p>
<p>(4) numeric::solve(eq, var=a..b, AllRealRoots)    返回方程（一个未知数）在[a, b]范围内的全部实根的数值解.</p>
</blockquote>
<p>可以给一个初始值，找这附近的解</p>
<pre><code class="lang-matlab">numeric::solve(subs(E^y+x*y-E, x=-2), y=2);
</code></pre>
<p>也可以给区间范围</p>
<pre><code class="lang-matlab">numeric::solve(subs(E^y+x*y-E, x=-2), y=-2..3, AllRealRoots);
</code></pre>
<h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p>linsolve：求解线性方程组<br>RootOf：求解多项式的根<br>solve：求解方程组和不等式组(具见上)<br>testeq：检验两个表达式是否相等<br>divide(p,q,[x])多项式除法，返回商和余</p>
<pre><code class="lang-matlab">testeq(0.5,1/2)//TRUE，不能测三个参数
divide(x^5,x+1,[x])
</code></pre>
<h3 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h3><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>limit(表达式,自变量趋向值,&lt;趋向方向&gt;)</p>
<p>使用infinity,-infinity表示无穷；</p>
<p>使用Left,Right表示左极限和右极限，默认双侧极限</p>
<pre><code class="lang-matlab">limit(a*(1 - cos(x))/x^2, x=1);
limit(a*(1 - cos(x))/x^2, x);//即x=0
limit((1 + 1/n)^n, n = infinity);
limit(1/x, x = 0, Left);
</code></pre>
<p>返回值若为undefined，表示极限不存在</p>
<h5 id="重极限"><a href="#重极限" class="headerlink" title="重极限"></a>重极限</h5><p>如果存在，则先算一层再算一层</p>
<pre><code class="lang-matlab">f:=(x,y)--&gt; ((x*y + 1)^(1/2) - 1)/(x*y)
limit(limit(f(x,y),x=0),y=0)
</code></pre>
<h4 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h4><h5 id="显函数"><a href="#显函数" class="headerlink" title="显函数"></a>显函数</h5><p>使用映射，如：</p>
<pre><code class="lang-matlab">delete x;
f:=x-&gt;exp(x)+x^2;
</code></pre>
<p>可以直接求导：</p>
<pre><code class="lang-matlab">f&#39;;
D(f);//二者等效
</code></pre>
<p>可以带入值运算：</p>
<pre><code class="lang-matlab">D(f)(x);  D(f)(1);
f&#39;(x);  f&#39;(1);
</code></pre>
<p>可以使用函数diff//还是觉得很迷，这样的出来的无法计算数值</p>
<p>diff(f, x $ n)返回 <em>n</em> 阶导数</p>
<pre><code class="lang-matlab">delete f,x:
f:=x-&gt;x^3;
diff(f(x),x)
</code></pre>
<pre><code class="lang-matlab">delete n,x;
diff(sin(n*x)*sin(x)^n, x);
diff(sin(n*x)*sin(x)^n, x $ 2);
diff(sin(x), x $ n) $ n=1..8;
</code></pre>
<pre><code class="lang-matlab">f:=(E^x)*cos(x):
diff(f,x$36);
</code></pre>
<p>抽象函数：</p>
<pre><code class="lang-matlab">delete x,y:
eq:=diff(E^y(x)+x*y(x)-E, x);//不能写成y
S:=solve(eq, diff(y(x), x));//求dy/dx
d1y_x:=-y(x)/(x+exp(y(x)))://S的结果
d2y_x:=diff(d1y_x, x);
d2y_x:=normal(subsex(d2y_x, diff(y(x), x)=d1y_x));
</code></pre>
<p>隐函数求导可以使用公式：</p>
<script type="math/tex; mode=display">
\frac{dy}{dx}=-\frac{F_x}{F_y}</script><script type="math/tex; mode=display">
\frac{d^2y}{dx^2}=\frac{\partial}{\partial x}(\frac{dy}{dx})+\frac{\partial}{\partial y}(\frac{dy}{dx})\frac{dy}{dx}</script><pre><code class="lang-matlab">F:=E^y+x*y-E:
d1y_x:=-diff(F,x)/diff(F,y);
diff(d1y_x, x)+diff(d1y_x, y)*d1y_x;
d2y_x:=normal(%);
</code></pre>
<p>也可以使用微分法。</p>
<pre><code class="lang-matlab">delete x,y,dx,dy:
F:=E^y+x*y-E;
dF:=diff(F,x)*dx+diff(F,y)*dy;
solve(dF,dy);
//然后把dx拉过去即可，然后用上面的公式求二阶导
</code></pre>
<h5 id="隐函数"><a href="#隐函数" class="headerlink" title="隐函数"></a>隐函数</h5><pre><code class="lang-matlab">delete x,y:
diff(E^y(x)+x*y(x)-E=0,x);
solve(%,y&#39;(x))

//上面的二阶导：
diff(-y(x)/(x + exp(y(x))),x);
normal(subsex(%,diff(y(x),x)=-y(x)/(x + exp(y(x)))))
</code></pre>
<h5 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h5><pre><code class="lang-matlab">delete x,y,t,a:
x:=a*(t-sin(t));
y:=a*(1-cos(t));
d1:=diff(y,t)/diff(x,t);
d2:=simplify(diff(d1,t)/diff(x,t))
</code></pre>
<h5 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h5><p>diff(f, x1, x2, …)    对自变元x1, x2, …依次求高阶偏导数，例如diff(f, y, x)即先x再y(?)</p>
<p> 命令gradient用来计算多元函数的梯度（列向量），语法格式：</p>
<p>gradient(f, x)，梯度是对每个元的偏导数的向量，$\nabla$</p>
<pre><code class="lang-matlab">f:=(x,y)--&gt;(sqrt(1-x*x-y*y)):
grf:=gradient(f(x,y),[x,y]);//列向量
</code></pre>
<p>例如：</p>
<pre><code class="lang-matlab">delete x,y:
f:=(x,y)-&gt;-x^2/4-y^2/6;
D([1],f);
D([1],f)(-1,1);
D([2],f);
D([2],f)(-1,1);
</code></pre>
<p>或：</p>
<pre><code class="lang-matlab">g:=-x^2/4-y^2/6;
diff(g, x);
subs(diff(g,x), x=-1, y=1);
diff(g, y);
subs(diff(g,y), x=-1, y=1);
</code></pre>
<p>求梯度：</p>
<pre><code class="lang-matlab">f:=(x,y)-&gt;-x^2/4-y^2/6;
Gr:=gradient(f(x,y), [x, y]);//返回列向量
</code></pre>
<p>例如：</p>
<pre><code class="lang-matlab">z:=ln(sqrt(x*x+y*y)):
simplify(diff(z,x,x)+diff(z,y,y));
</code></pre>
<p>注意不等价：</p>
<pre><code class="lang-matlab">u:=f((s-sqrt(3)*t)/2,(sqrt(3)*s+t)/2);
u:=f(x,y):
x:=(s-sqrt(3)*t)/2:
y:=sqrt(3)*s+t)/2:
</code></pre>
<p>但是顺序换回来就等价了，即u赋值放在最后</p>
<p>两种写法等价：</p>
<pre><code class="lang-matlab">delete x,y,z,f:
w:=f(x+y+z, x*y*z):
diff(w,x);
diff(w,x,z);

delete x,y,z,f:
w:=(x,y,z)-&gt;f(x+y+z, x*y*z);
D([1],w);
D([1,3],w);
</code></pre>
<h5 id="雅克比"><a href="#雅克比" class="headerlink" title="雅克比"></a>雅克比</h5><p>使用jacobian计算函数组f1,f2…fm关于x1,x2…xn的雅可比矩阵：</p>
<pre><code class="lang-matlab">jacobian([f1,...,fm],[x1,...,xm])
</code></pre>
<p>再对结果使用det命令返回雅克比行列式。</p>
<p>以用全微分法和解线性方程组求隐函数组的偏导数，其求解公式为：</p>
<script type="math/tex; mode=display">
\left(\matrix{dx\\dz}\right)=-\left(\matrix{F_y&F_z\\G_y&G_z}\right)\left(\matrix{F_x\\G_x}\right)dx</script><pre><code class="lang-matlab">-inverse(jacobian([F,G],[x,y]))*jacobian([F,G],[z]);
subs(%,[x=-1, y=-1, z=sqrt(2)]);
</code></pre>
<h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><h5 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h5><p>命令int(f, x)返回被积函数的一个原函数.</p>
<blockquote>
<p>这个f建议现输，用一个变量可能会出点问题</p>
</blockquote>
<p>与一般手算积分的区别：</p>
<ul>
<li>省略任意常数</li>
<li>对数的真数部分都不带绝对值号</li>
</ul>
<blockquote>
<p>不能计算出原函数时，命令int返回待求的积分表达式</p>
</blockquote>
<pre><code class="lang-matlab">delete a,x;
int(1/(a-x), x);
int(1/sqrt(a^2-x^2), x);
int(1/sqrt(a^2-x^2), x) assuming a&gt;0;//结果不一样
int(x*(x+1)^n, x) assuming n in N_;
</code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li>直接计算有理函数可能出现虚数解，应当先拆后算，见语法-代数-表达是变幻-分解-partfrac</li>
</ul>
</blockquote>
<h6 id="换元积分法"><a href="#换元积分法" class="headerlink" title="换元积分法"></a>换元积分法</h6><p>intlib::changevar(integral, eq, var) </p>
<blockquote>
<p>命令intlib::changevar(integral, eq, var)会自动检查换元的方程eq能否解出新积分变量（对于第二换元法，就是是否能解出反函数，这在理论上是必须满足的条件），如果不能唯一地解出来（反函数不存在）或者解不出来（非初等函数），系统会分别给出警告信息（命令返回换元后的结果，该结果是否合理需要小心验证）或者错误信息（命令不返回计算结果）.</p>
</blockquote>
<p>如果不使用hold，那么直接返回最终结果，跟一般计算没什么区别，如果要看中间过程，需要hold：</p>
<pre><code class="lang-matlab">//第一类换元法
intlib::changevar(hold(int(x/sqrt(1-x^2),x)), v=1-x^2, v);
int(-1/(2*v^(1/2)), v);//再计算
subs(%, v=1-x^2);
</code></pre>
<pre><code class="lang-matlab">//第二类换元法
delete t,v,x;
intlib::changevar(hold(int(x/sqrt(1-x^2),x)), x=sqrt(1-v), v);
intlib::changevar(hold(int(x/sqrt(1-x^2),x)), x=-sqrt(1-v), v);//两种情况分别讨论

intlib::changevar(hold(int(x/sqrt(1-x^2),x)), x=sin(t), t); //或更好的换元法
Simplify((2^(1/2)*sin(2*t))/(2*(cos(2*t)+1)^(1/2))) assuming cos(t)&gt;0;
</code></pre>
<h6 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h6><p>intlib::byparts(integral, du)</p>
<p>du是换到d里面的整体表达式(换前，即在原式看得到的部分)</p>
<pre><code class="lang-matlab">//解法一
intlib::byparts(hold(int(exp(a*x)*cos(b*x), x)),exp(a*x));
intlib::byparts(hold(int(exp(a*x)*sin(b*x), x)),exp(a*x));
solve(&#123;P=exp(a*x)*cos(b*x)/a+b/a*Q, 
Q=exp(a*x)*sin(b*x)/a-b/a*P&#125;, &#123;P,Q&#125;);
</code></pre>
<pre><code class="lang-matlab">//解法二
intlib::byparts(hold(int(exp(a*x)*cos(b*x), x)), exp(a*x));
exp(a*x)*cos(b*x)/a + b/a*intlib::byparts(hold(int(exp(a*x)*
sin(b*x), x)), exp(a*x));
collect(%,exp(a*x)); //合并含有exp(a*x)的两个函数表达式
solve(P=(cos(b*x)/a+(b*sin(b*x))/a^2)*exp(a*x)-(b/a)^2*P, P);
</code></pre>
<h5 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h5><p>int(f,x=a..b)计算定积分</p>
<h6 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h6><pre><code class="lang-matlab">int(1/(x^2+x-2),x=2..infinity)
</code></pre>
<h5 id="重积分"><a href="#重积分" class="headerlink" title="重积分"></a>重积分</h5><p>可以用展开为一重积分的式子来计算：</p>
<pre><code class="lang-matlab">int(int(cos(y*y),y=x..1),x=0..1)
int(int(exp(y/x),y=x*x..x),x=1/2..1)
</code></pre>
<h4 id="极值"><a href="#极值" class="headerlink" title="极值"></a>极值</h4><h5 id="黑塞矩阵"><a href="#黑塞矩阵" class="headerlink" title="黑塞矩阵"></a>黑塞矩阵</h5><p>命令hessian用来计算多元函数的黑塞矩阵，语法格式：</p>
<pre><code class="lang-matlab">hessian(f, x)
</code></pre>
<p>二元函数的黑塞矩阵$H_f(P_0)$是实对称矩阵，且其行列式为$AC-B^2$：</p>
<script type="math/tex; mode=display">
\large\left(\matrix{\frac{\partial^2f}{\partial x^2}&
\frac{\partial^2f}{\partial x\partial y}\\
\frac{\partial^2f}{\partial x\partial y}&
\frac{\partial^2f}{\partial y^2}}\right)</script><p>代入点，若矩阵正定，则在点处严格极小值；若负定，严格极大值，否则不能取极值，是鞍点；若行列式为0，无法判断。</p>
<h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><pre><code class="lang-matlab">taylor(cos(x),x,5)
</code></pre>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><h6 id="一般矩阵"><a href="#一般矩阵" class="headerlink" title="一般矩阵"></a>一般矩阵</h6><p> 命令matrix(m, n)创建m行n列的零矩阵.</p>
<p>该矩阵可以跟二维数组一样使用。</p>
<p>matrix(m,n,对应二维数组)创建矩阵：</p>
<pre><code class="lang-matlab">matrix(2,3,[[1,2,3],[4,5,6]])
</code></pre>
<p>可以不写行列：</p>
<pre><code class="lang-matlab">matrix([[1,2,3],[4,5,6]])
</code></pre>
<p>可以使用一个长度小于m的一维数组补足第一列，其余部分用0代替。</p>
<pre><code class="lang-matlab">matrix(3,5,[1,2,3])
</code></pre>
<p>使用二维数组则按照常规理解灵活补足：</p>
<pre><code class="lang-matlab">matrix(3,5,[[1],[2,3],[4,5,6]])
</code></pre>
<p>创建行向量和列向量matrix([[]]), matrix([])，如：</p>
<pre><code class="lang-matlab">matrix([[1,2,3]]) //行
matrix([1,2,3]) //列
</code></pre>
<h6 id="雅克比矩阵"><a href="#雅克比矩阵" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h6><pre><code class="lang-matlab">jacobian([f1,f2,...,fn],[x1,x2,...,xn])
</code></pre>
<h5 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h5><p>det(A)<br>det(A, Normal=FALSE)<br>说明：<br>A：方阵，矩阵类型；<br>Normal：可选项，默认值为Normal=TRUE，即计算行列式时系统自动使用命令normal进行通分运算再返回计算结果，<br>这样有可能需要较长的耗用时间，设置Normal=FALSE，可以得到未通分的结果，并且缩短耗用时间.</p>
<pre><code class="lang-matlab">y:=matrix(3,3,[[1,3,3],[4,5,6],[7,8,9]])
det(y)
</code></pre>
<pre><code class="lang-matlab">det(matrix([[1,x*(x+1),x],[x^2,1,x^2],[1,2*x,x*(x-1)]]),Normal=FALSE) //这个未化简，下面化简了：
det(matrix([[1,x*(x+1),x],[x^2,1,x^2],[1,2*x,x*(x-1)]]))
</code></pre>
<h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><h6 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h6><p>+即可</p>
<h6 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h6><p>*即可，注意左右顺序，如：</p>
<pre><code class="lang-matlab">matrix([[1,2,3]])*matrix([3,4,5]) #得到1阶矩阵
</code></pre>
<pre><code class="lang-matlab">matrix([[1,2,3],[4,5,6]])*matrix([[3,4],[5,6],[7,8]])
</code></pre>
<p>标量乘法同理。</p>
<h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>使用.符号链接两个向量，如果规格不同自动补0</p>
<pre><code class="lang-matlab">matrix([1,2]).matrix([[3,4,5]])
</code></pre>
<h6 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h6><p>如果左边是列向量，右边是行向量，*号拓展生成矩阵，</p>
<pre><code class="lang-matlab">matrix([1,2,3])*matrix([[3,4,5]])
</code></pre>
<h6 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h6><pre><code class="lang-matlab">x:=matrix(3,3,[[1,2,3],[8,9,4],[7,6,5]]);
linalg::rank(x)
</code></pre>
<h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>用行矩阵或列矩阵创建向量。</p>
<h5 id="模长"><a href="#模长" class="headerlink" title="模长"></a>模长</h5><p>norm(v,2)</p>
<p>注意如果norm(v,n),$n\in\Z$，表示式子：</p>
<script type="math/tex; mode=display">
\sqrt[n]{\sum i^n}</script><pre><code class="lang-matlab">x:=matrix([1,2]) //如果数组不行
norm(x,2)
</code></pre>
<h5 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h5><p>将向量化为方向向量，即每个元除以它的模长。返回向量。</p>
<pre><code class="lang-matlab">linalg::normalize(x)
</code></pre>
<h6 id="方向角"><a href="#方向角" class="headerlink" title="方向角"></a>方向角</h6><p>先化单位向量，然后迭代arccos：</p>
<pre><code class="lang-matlab">x:=matrix([[-1,1,-sqrt(2)]]):
arccos(linalg::normalize(x)[i]) $i=1..3
</code></pre>
<h5 id="运算-1"><a href="#运算-1" class="headerlink" title="运算"></a>运算</h5><h6 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h6><p>linalg::scalarProduct(a, b)<br>linalg::scalarProduct(a, b, Real)<br>说明：<br>a, b：元素个数相等的向量（行或列皆可），矩阵类型；<br>Real：可选项，注意首字母R需要大写，默认格式linalg::scalarProduct(a, b)按照复向量的数量积的数学定义返回</p>
<p>只能算列向量。若下面是matrix([[1,2]])和matrix([[3,4]])无效</p>
<pre><code class="lang-matlab">x:=matrix([1,2])
y:=matrix([3,4])
linalg::scalarProduct(x,y)
</code></pre>
<h6 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h6><p>只有在 3 维向量之间才有向量积运算</p>
<p>linalg::crossProduct(x,y)</p>
<pre><code class="lang-matlab">x:=matrix([1,2,3])
y:=matrix([4,5,6])
linalg::crossProduct(x,y)
</code></pre>
<h6 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h6><p>linalg::angle(x,y) //或y,x，结果相同。</p>
<p>对于二维向量与x轴正向夹角，可以用arg：</p>
<p>命令arg计算复数及其相应的平面向量 (<em>x</em>, <em>y</em>) 的辐角，即向量与 <em>x</em> 轴正向所成的角，以逆时针为正向，</p>
<p>规定辐角的范围是. 语法格式为：</p>
<p>arg(x+iy)</p>
<p>arg(x, y)</p>
<pre><code class="lang-matlab">f:=(x,y)--&gt;(x*x-y*y)/2:
x0:=1:
y0:=-1:
fx:=D([1],f)(x0,y0):
fy:=D([2],f)(x0,y0):
t0:=arg(fx,fy); //pi/4
</code></pre>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><h3 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h3><p>plot(元件(可变参数),默认参数)绘制图像</p>
<p>注：三维图像可以鼠标拖拽更换视角</p>
<h4 id="绘图参数"><a href="#绘图参数" class="headerlink" title="绘图参数"></a>绘图参数</h4><p>GridVisible = TRUE 显示网格 #G</p>
<p>Scaling = Constrained 或 #C 坐标轴等比</p>
<p>Mesh = 121 采样点数</p>
<p>AdaptiveMesh = 4 自适应采样(0关闭)</p>
<blockquote>
<p>Mesh=[m, n]，即XMesh=m，YMesh=n.</p>
<p>将变量 x 和 y 的取值范围分别进行等分和等分，获得平面 <em>Oxy</em> 上的矩形网格，(参数方程则对应方程)</p>
<p>生成空间中相应的 <em>x</em> 线和 <em>y</em> 线，进而生成网格状曲面.  默认值Mesh=[25, 25].</p>
<p>Submesh=[s, t]，即XSubmesh=s，YSubmesh=t.</p>
<p>如果XMesh或YMesh的值不够大，二元函数图像的网格状曲面的分辨度就不够高，看起来就不够光滑和细致.</p>
<p>Submesh可以得到平面 <em>Oxy</em> 上的加密的矩形网格，从而生成分辨度更高的网格状曲面，看起来更光滑更细致. </p>
<p>默认值Submesh=[0, 0]，即没有额外的加密. </p>
<p>当XMesh=m，XSubmesh=s的时候，<em>x</em> 的取值范围先等分成个小区间，对每一个小区间，</p>
<p>再进一步额外等分成个小区间，从而在 <em>x</em> 的取值范围，总共取得了个均匀等距的采样点.</p>
<p><em>y</em> 的取值范围也以同样的方式获得额外加密的采样点，从而与 <em>x</em> 的采样点一起构成额外加密的网格.</p>
<p>AdaptiveMesh=n.</p>
<p>采用自适应采样技术来绘制函数图像，非负整数 n 是自适应采样的深度，默认值为 0，即不启用自适应采样；</p>
<p>当 n 是正整数时，启用自适应采样，值越大采样点越细密，图像逼真度越高，但是耗时也越长.</p>
<p>建议从默认值开始，以 1 为步长逐步增加深度 <em>n</em>，直到获得满意的图像为止.</p>
<p>注1：根据对Mesh的解释，XMesh和YMesh都至少是2，否则不能产生曲面的图像；<br>注2：因为系统默认由Mesh决定的 x 线和 y 线显示在曲面上，并且它们的数量在视觉上恰好合适，<br>所以不建议修改Mesh的值；<br>注3：由Submesh产生的更细密的网格线不显示在曲面上</p>
</blockquote>
<p>XLinesVisible=TRUE / FALSE</p>
<p>YLinesVisible=TRUE / FALSE</p>
<blockquote>
<p>以X为例。默认值为TRUE，在曲面上显示由Mesh确定的 <em>x</em> 线；若设置为FALSE，曲面上不显示 <em>x</em> 线.</p>
<p>对Surface，将X,Y改为U,V</p>
</blockquote>
<h1 id="x-1-绘制水平虚线-黑色"><a href="#x-1-绘制水平虚线-黑色" class="headerlink" title="x = 1 绘制水平虚线(黑色)"></a>x = 1 绘制水平虚线(黑色)</h1><h1 id="y-1-绘制垂直虚线-黑色"><a href="#y-1-绘制垂直虚线-黑色" class="headerlink" title="y = -1 绘制垂直虚线(黑色)"></a>y = -1 绘制垂直虚线(黑色)</h1><p>ViewingBox = [x1..x2,y1..y2] 可视范围</p>
<p>AxesVisible=FALSE 不显示坐标轴(默认显示)</p>
<p>Axes=Origin 或 #O 坐标原点显示在图形里</p>
<p>AxesTitles=[列表] 坐标轴名称</p>
<p>YAxisTitle = “y” y轴名称 //da tr X同理</p>
<p>ViewingBox=[x1..x2,y1..y2] 可视区域(会覆盖#O)//三维还有z</p>
<p>Height=80 高度(mm)</p>
<p>Width=120 宽度(mm)</p>
<p>Header=”123” 顶部文字</p>
<p>Footer=”123” 底部文字</p>
<blockquote>
<p>注：当图像分辨率不够高时，可以在命令plot::Function3d、plot::Implicit3d和plot::Surface设置选项AdaptiveMesh=3（自适应采样的深度为3，深度取3通常就足够了，该正整数值越大耗用时间越长），或者在命令plot::Function3d和plot::Surface设置选项Submesh=[4,4]（每个采样点区间内额外增加4个采样点，在命令plot::Implicit3d改成设置Submesh=[4,4,4]，加密4个采样点通常就足够了，该正整数值越大耗用时间越长），都能较好地提高图像的分辨率，改善图像的逼真程度.</p>
</blockquote>
<p>使用VisibleBefore和VisibleAfter、TimeRange控制分步动画。</p>
<p>分步动画示例：</p>
<pre><code class="lang-matlab">Py:=plot::Group3d(plot::Point3d(
[x,y,f(x,y)], x=1/2..0, PointSize=2,
 VisibleBefore=10, TimeRange=0..10)
   $ y=-0.95..0.95 step 0.1):
  //取定y，令x趋于0所得到的动点族，动画在第0至10秒演示，在第10秒之前可见
Px:=plot::Group3d(plot::Point3d
([0,u,f(0,u)], u=y..0, PointSize=2,
VisibleAfter=10, TimeRange=10..15)
$ y=-0.95..0.95 step 0.1):
  //取定x=0，令y趋于0所得到的动点族，动画在第10秒后可见，在第10至15秒演示
plot(Gf, Cy, Py, Px, Ly, #C);
</code></pre>
<h4 id="元件参数"><a href="#元件参数" class="headerlink" title="元件参数"></a>元件参数</h4><blockquote>
<p>非泛用的见各元件</p>
</blockquote>
<h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><h6 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h6><p>默认RGB::Blue</p>
<ul>
<li>Color=RGB::Red<br>常见的(但不常写)颜色：Grey,Grey50</li>
<li>Color=[r,g,b] //取值为[0,1],其中[0,0,0]为黑,[1,1,1]为白</li>
</ul>
<blockquote>
<p>查看颜色的RGB名字：//如无返回近似的</p>
<pre><code class="lang-matlab">RGB::colorName([0,0,0])
</code></pre>
<p>查看某颜色str的颜色效果</p>
<pre><code class="lang-matlab">RGB::plotColorPalette(&quot;PrussianBlue&quot;)
</code></pre>
</blockquote>
<h6 id="RGBa"><a href="#RGBa" class="headerlink" title="RGBa"></a>RGBa</h6><p>三元列表增设第四个参数a，取值范围为$[0,1]$，从完全透明到完全不透明</p>
<p>可以用链接运算符与一般的颜色单词连用，如：</p>
<pre><code class="lang-matlab">RGB::Black.[0.25]
</code></pre>
<h5 id="动画参数"><a href="#动画参数" class="headerlink" title="动画参数"></a>动画参数</h5><p><strong>基本方法</strong>：添加一个变量标识符，然后在参数区域的<strong>变量范围之后</strong>给这个标识符确定一个范围，如下所示：</p>
<pre><code class="lang-matlab">delete a;//a是动画参数
f1 := plot::Function2d(sin(a*x), x = 0..2*PI,a=1..3):
plot(f1,#C)
</code></pre>
<pre><code class="lang-matlab">f2 := plot::Function2d(sin(a*x),a=1..3,x = 0..2*PI);
plot(f2,#C,#O)//x是动画参数
</code></pre>
<p>Frames = 40 帧数</p>
<p>TimeRange = 0..10时长</p>
<pre><code class="lang-matlab">plot(plot::Function2d(sin(b*x), x = 0..2*PI, b = 1..2, Frames = 100,TimeRange=0..1)):
</code></pre>
<p>若值域含动画参数，可以模拟绘制过程：</p>
<pre><code class="lang-matlab">C2 := plot::Curve2d([sin(t), cos(t)], t = 0..b, b=0..2*PI);
P := plot::Point2d([sin(t), cos(t)], t=0..2*PI);
plot(C2,P,#C)
</code></pre>
<blockquote>
<p>动画参数可以从大到小，从小到大或其他特殊变化。</p>
</blockquote>
<p>使用AdaptiveMesh=3改善绘画效果，避免曲线折线化：</p>
<pre><code class="lang-matlab">curve := plot::Curve3d([sin(t)*cos(20*t), sin(t)*sin(20*t), cos(t)],t = 0..b, b = 0..PI,AdaptiveMesh=3):
plot(curve,#C)
</code></pre>
<p>当然也可以加上Mesh(或XMesh,YMesh，其乘积为Mesh)</p>
<pre><code class="lang-matlab">plot(plot::Curve2d([x,sin(1/x)],x=1/b..1,b=PI/2..20*PI+PI/2,Mesh=1000,AdaptiveMesh=3,Frames=21),   plot::Point2d([1/b,sin(b)],b=PI/2..20*PI+PI/2,Frames=21),ViewingBox=[0..1,-1..1]);
</code></pre>
<p>Submesh 额外采样点密度，默认0，这三者主要用于奇点</p>
<h5 id="线形"><a href="#线形" class="headerlink" title="线形"></a>线形</h5><p>LineStyle</p>
<ul>
<li>Solid 实线(默认)</li>
<li>Dashed 虚线</li>
<li>Dotted 点划线</li>
</ul>
<h5 id="线宽"><a href="#线宽" class="headerlink" title="线宽"></a>线宽</h5><p>LineWidth，单位mm，要用其他单位，使用诸如unit::cm(默认0.35)</p>
<h5 id="点型"><a href="#点型" class="headerlink" title="点型"></a>点型</h5><p>默认值是PointStyle=FilledCircles</p>
<ul>
<li>Squares//空心正方形</li>
<li>FilledSquares//实心正方形</li>
<li>Circles//空心圆</li>
<li>FilledCircles//实心圆</li>
<li>Crosses//+十字</li>
<li>XCrosses//x十字</li>
<li>Diamonds//空心斜正方形</li>
<li>FilledDiamonds//实心斜正方形</li>
<li>Stars//密*形星</li>
</ul>
<h5 id="点宽"><a href="#点宽" class="headerlink" title="点宽"></a>点宽</h5><p>PointSize 默认值是PointSize=1.5，单位是毫米. </p>
<h4 id="元件"><a href="#元件" class="headerlink" title="元件"></a>元件</h4><h5 id="Function2d"><a href="#Function2d" class="headerlink" title="Function2d"></a>Function2d</h5><p>函数</p>
<p>plot::Function2d(f,x=xmin..xmax,<attributes>)</attributes></p>
<pre><code class="lang-matlab">delete x;
f1 := plot::Function2d(sin(x), x = 0..2*PI);
</code></pre>
<blockquote>
<p>如果在某处具有奇异性，则会有铅锤的虚线，如$\sqrt{1-x^2}$的$x=\pm1$处</p>
<p>对比不同元件画一个圆的质量：</p>
<ul>
<li>Function2d 在接近$x=\pm1$时不佳(因为奇异性)</li>
<li>Implicit2d比前者好，但仍有瑕疵</li>
<li>Curve2d/Polar质量较好;Polar不加#C也能等比例显示</li>
</ul>
</blockquote>
<h6 id="Function3d"><a href="#Function3d" class="headerlink" title="Function3d"></a>Function3d</h6><p>plot::(二元函数,x范围，y范围) //如果不提供范围，默认为$[-5,5]$</p>
<p>有参数XLinesVisible,YLinesVisible,ZContours(无X,Y的)</p>
<pre><code class="lang-matlab">plot::Function3d(-x-y,x=-2..2,y=-2..2)
</code></pre>
<blockquote>
<p>用命令plot::Surface按照参数方程绘制圆锥面比用命令plot::Function3d的效果更好</p>
</blockquote>
<h5 id="Curve2d"><a href="#Curve2d" class="headerlink" title="Curve2d"></a>Curve2d</h5><p>参数方程</p>
<p>plot::Curve2d([x的参数方程,y的参数方程],参数取值范围)</p>
<pre><code class="lang-matlab">curve := plot::Curve2d([r*sin(r), r*cos(r)], r = -6..6);
</code></pre>
<pre><code class="lang-matlab">curve := plot::Curve3d([sin(thet)*cos(20*thet),
sin(thet)*sin(20*thet),cos(thet)],thet = 0.2*a..a, a = PI..0):
</code></pre>
<h6 id="Curve3d"><a href="#Curve3d" class="headerlink" title="Curve3d"></a>Curve3d</h6><p>同理，加多一个参数方程。</p>
<h5 id="Implicit2d"><a href="#Implicit2d" class="headerlink" title="Implicit2d"></a>Implicit2d</h5><p>隐函数</p>
<p>plot::Implicit2d(方程,x取值范围, y取值范围)</p>
<pre><code class="lang-matlab">plot(plot::Implicit2d((x-y)*(x+y), x = -1..1, y = -1..1))
plot(plot::Implicit2d(x^2 - y^2 = (x - a*y)*(x^2 + y^2),x = -2..2, y = -2..2, a = -2..2)
</code></pre>
<blockquote>
<p>可以绘制二元函数的等高线/等值线：</p>
<p>plot::Implicit2d(f(x, y), x=xmin..xmax, y=ymin..ymax, Contours=c)</p>
<script type="math/tex; mode=display">
f(x,y)=c</script><p>plot::Implicit2d(f(x, y), x=xmin..xmax, y=ymin..ymax, Contours=[c1, c2, …, cn])</p>
<script type="math/tex; mode=display">
f(x,y)=c_1,\dots f(x,y)=c_n</script></blockquote>
<p>有参数Contours，即绘制等高线在xOy的投影</p>
<pre><code class="lang-matlab">z0:=0.4:
Ct:=plot::Implicit2d(sin(x-y), 
x=-PI..PI, y=-PI..PI, Contours=z0):
plot(Ct, #C);
</code></pre>
<p>命令plot::Implicit2d可通过设置图形属性Contours绘制二元函数的等高线，并设置图像属性</p>
<p>LineColorFunction实现按照高度来着色，从低到高由蓝色渐变到红色. 语法格式：</p>
<p>plot::Implicit2d(f(x, y), x=xmin..xmax, y=ymin..ymax, Contours=[c1, c2, …, cn],<br>                          LineColorFunction=((x,y)-&gt;[(f(x,y)-m)/(M-m),0,(M-f(x,y))/(M-m)]))</p>
<p>说明：</p>
<p>m和M分别是在取值范围内的最小值和最大值；</p>
<p>这条命令绘制 <em>n</em> 条等高线, f(x,y)=c_1, …,f(x,y)= c_n… ,，按照高度c1, c2, …, cn从低到高的顺序（即数值从小到大），</p>
<p>等高线的颜色由蓝色渐变到红色.</p>
<pre><code class="lang-matlab">Gzc:=plot::Implicit2d(f(x,y), x=-5..5, y=-5..5, Contours=[$0..1 step 0.1],LineColorFunction=((x,y)-&gt;[f(x,y), 0, 1-f(x,y)])):
plot(Gzc, #C);
</code></pre>
<h6 id="Implicit3d"><a href="#Implicit3d" class="headerlink" title="Implicit3d"></a>Implicit3d</h6><p>隐函数，由于耗用时间较其他方法长，分辨率也较其他方法低，不推荐使用</p>
<h5 id="Inequaity"><a href="#Inequaity" class="headerlink" title="Inequaity"></a>Inequaity</h5><p>绘制不等式确定的平面(注意不是空间)点集</p>
<p>plot::Inequality(ineq, x=xmin..xmax, y=ymin..ymax, Attributes)<br>plot::Inequality([ineq1, ineq2, ……], x=xmin..xmax, y=ymin..ymax, Attributes)</p>
<p>例如：</p>
<pre><code class="lang-matlab">Ig:=plot::Inequality([x^2+(y-1)^2&gt;1, x^2+(y-2)^2&lt;=4], x=-3..3, y=-1..5): //平面点集(在图中范围内是绿色的，否则是红色的)
plot(Ig, #C);
</code></pre>
<p>(1) FillColorTrue，满足不等式（组）的平面点集的颜色，默认值RGB::Green；<br>(2) FillColorFalse，不满足不等式（组）的平面点集的颜色，默认值RGB::Red；<br>(3) FillColorUnknown，系统不能判断部分的颜色，默认值RGB::Black.</p>
<p>由于命令plot::Inequality对不等号&gt;和≥、&lt;和≤不加区分，所以边界常常是系统不能判断的部分，<br>而且不论开集、闭集，边界默认都绘成实线，而且上述图形属性的默认值常常不符合需要，可以作出如下调整：<br>(1) 把图形属性FillColorFalse和FillColorUnknown都设置为RGB::White（白色），<br>把FillColorTrue设置成我们想用的颜色；<br>(2) 另外用plot::Function2d、plot::Curve2d、plot::Implicit2d或者plot::Line2d等命令绘制边界，<br>用虚线（设置LineStyle=Dashed）表示开集的边界，用实线（系统默认值）表示闭集的边界；<br>(3) 如果点(a, b)不属于定义域，则用命令plot::Circle2d(r, [a,b])画一个半径为r的圆圈（r取相对比较小的数值），<br>表示去掉该点.</p>
<p>例如：</p>
<pre><code class="lang-matlab">Ig:=plot::Inequality([x^2+(y-1)^2&gt;1,x^2+(y-2)^2&lt;=4], x=-3..3, y=-1..5,FillColorFalse=RGB::White,FillColorUnknown=RGB::White):
Cg1:=plot::Curve2d([2*cos(t),2+2*sin(t)], t=0..2*PI):
Cg2:=plot::Curve2d([cos(t),1+sin(t)],t=0..2*PI, LineStyle=Dashed):
plot(Ig, Cg1, Cg2, #C);
</code></pre>
<h5 id="Plane"><a href="#Plane" class="headerlink" title="Plane"></a>Plane</h5><p>生成平面</p>
<p>可以用：</p>
<p>①平面点法式方程，第一个参数是点(三元数组即DOM_LIST)，第二个参数是法向量(三元数组)</p>
<p>②平面三点式方程，前三个三个参数分别是三个点</p>
<p>两种格式都不需要设置直角坐标范围，系统会根据在同一幅图里面其他的图形对象的直角坐标范围自动匹配</p>
<h5 id="Polar"><a href="#Polar" class="headerlink" title="Polar"></a>Polar</h5><p>极坐标</p>
<p>方程为[r方程,$\theta$方程]</p>
<pre><code class="lang-matlab">plot(plot::Polar([r, PI/3], r = 0.8..1))//直线
plot(plot::Polar([arccos(sin(r)),r], r = 0..2*PI))
</code></pre>
<p>可以额外使用Mesh默认参数，如Mesh=400，提高平滑感。</p>
<p>这个也可以用AdaptiveMesh=4</p>
<h5 id="Point2d"><a href="#Point2d" class="headerlink" title="Point2d"></a>Point2d</h5><p>1）plot::Point2d(x, y, <a=a1..a2>, <attributes>)<br>2）plot::Point2d([x, y], <a=a1..a2>, <attributes>) </attributes></a=a1..a2></attributes></a=a1..a2></p>
<p>PointStyle：点的形状，默认值是PointStyle=FilledCircles，还有8种形状可用：Squares, FilledSquares, Circles, Crosses, XCrosses, Diamonds, FilledDiamonds, Stars；</p>
<p>PointSize：点的尺寸，默认值是PointSize=1.5，单位是毫米. </p>
<pre><code class="lang-matlab">plot::Point2d(2, 2, PointSize = 50, PointColor = RGB::Grey50, PointStyle = Circles)
</code></pre>
<h6 id="Point3d"><a href="#Point3d" class="headerlink" title="Point3d"></a>Point3d</h6><p>同理</p>
<h6 id="PointList2d"><a href="#PointList2d" class="headerlink" title="PointList2d"></a>PointList2d</h6><p>plot::PointList2d(pts, <a=a1..a2>, <attributes>)<br>pts：点列坐标的列表，形如[[x1,y1],[x2,y2],… ,[xn,yn]]或者[[x[i],y[i]]$i=1..n]，列表类型，要有两重方括号； </attributes></a=a1..a2></p>
<pre><code class="lang-matlab">PL1 := plot::PointList2d([[1,1],[2,4],[3,9],
[4,16],[5,25]],PointStyle=Stars);
PL2 :=plot::PointList2d([[i,i^2]$i=1..5],PointStyle=Stars);
</code></pre>
<h5 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h5><p>参数(关于n的通项表达式,n范围)</p>
<h5 id="Line2d"><a href="#Line2d" class="headerlink" title="Line2d"></a>Line2d</h5><p>plot::Line2d([x1, y1], [x2, y2], <a=a1..a2>, <attributes>)<br>LineStyle、LineWidth和 LineColor来修饰直线段</attributes></a=a1..a2></p>
<pre><code class="lang-matlab">L2:=plot::Line2d([-3,-3],[3,3],LineStyle = Dashed,
LineWidth = 2.5*unit::mm, LineColor = RGB::Green):
</code></pre>
<h6 id="Line3d"><a href="#Line3d" class="headerlink" title="Line3d"></a>Line3d</h6><p>同理，给定两点，生成直线段。</p>
<h5 id="Arrow2d"><a href="#Arrow2d" class="headerlink" title="Arrow2d"></a>Arrow2d</h5><p>有向线段，首个坐标为箭尾，第二个为箭头</p>
<p>可以直接扔向量(dack)</p>
<pre><code class="lang-matlab">plot(plot::Arrow2d([0,0],[1,1]));
</code></pre>
<pre><code class="lang-matlab">delete t;
T:=b/a*2*PI:
a:=1:  b:=0.8: //修改b的值（0&lt;b&lt;=a），观察图像的变化
Cc:=plot::Curve2d(P_t(t), t=0..T, Color=RGB::Red): // 外摆线，t是曲线参数
// 以下图形对象当中，t都是动画参数 
Ct:=plot::Circle2d(b, O_t(t), t=0..T):
Arc:=plot::Arc2d(b, O_t(t), t+PI..t+PI+a/b*t, t=0..T,
                 Color=RGB::Green, LineWidth=0.7):
Arrow1:=plot::Arrow2d([0,0], O_t(t), t=0..T):
Arrow2:=plot::Arrow2d(O_t(t), P_t(t), t=0..T):
Ot:=plot::Point2d(O_t(t), t=0..T, Color=RGB::Blue):
Qt:=plot::Point2d(Q_t(t), t=0..T, Color=RGB::Black):
Pt:=plot::Point2d(P_t(t), t=0..T, PointSize=2, Color=RGB::Red):
plot(C, Cc, Ct, Arc, Arrow1, Arrow2, Ot, Qt, Pt, #C);
</code></pre>
<h6 id="Arrow3d"><a href="#Arrow3d" class="headerlink" title="Arrow3d"></a>Arrow3d</h6><p>有向空间线段：</p>
<pre><code class="lang-matlab">plot(plot::Arrow3d([0,1,0],[1,0,0]))
</code></pre>
<p>可以直接扔向量做点。其他元件可以类推。</p>
<h5 id="Rectangle2d"><a href="#Rectangle2d" class="headerlink" title="Rectangle2d"></a>Rectangle2d</h5><p>plot::Rectangle(xmin .. xmax, ymin .. ymax, <a = amin .. amax>, options)<br>选项Filled=TRUE将对矩形的内部进行填充，默认的设置是Filled=FALSE。<br>可以通过LineStyle、LineWidth 和 LineColor来设置边界线的属性。</a></p>
<pre><code class="lang-matlab">P1 := plot::Rectangle(-2..2, -2..2, Filled = TRUE
,FillColor = RGB::Red);
P2 := plot::Rectangle(1..5, 1..5, Filled = FALSE,
LineColor = RGB::Black, LineStyle = Dashed);
</code></pre>
<h6 id="Polygon2d"><a href="#Polygon2d" class="headerlink" title="Polygon2d"></a>Polygon2d</h6><p>plot::Polygon2d([pt2d1, pt2d2, …], <attributes>)<br>LinesVisible：线是否显示，默认值是LinesVisible=TRUE，即显示线，此时可以设置以下图形属性：<br>      · Color、LineStyle和LineWidth（默认值与plot ::Function2d的相同）；<br>      · Closed（默认值是Closed=FALSE，即终点[xn,yn]与始点[x1,y1]不连线）；<br>Filled：内部是否填充，默认值是Filled=FALSE，即内部不填充，若修改成Filled=TRUE，则此时可以设置以下图形属性：<br>      · FillColor（填充颜色，默认值是FillColor=RGB::Red）；<br>      · FillPattern（填充方式，默认值是FillPattern=DiagonalLines）；<br>PointsVisible：点是否显示，默认值是PointsVisible=FALSE，即不显示点，若修改成PointsVisible=TRUE，则此时可以设置以下图形属性：<br>      · PointSize（点尺寸，默认值是PointSize=1.5）；<br>      · PointStyle（点型，默认值是PointStyle=FilledCircles）. </attributes></p>
<pre><code class="lang-matlab">plot::Polygon2d([[cos(2*PI*k/5), sin(2*PI*k/5)] $ k = 0..4],Closed= TRUE,Filled=TRUE):
</code></pre>
<pre><code class="lang-matlab">n:=3://取n=1,2,3,...
C1:=plot::Circle2d(1,[0,0],Color=RGB::Green):
P1:=plot::Polygon2d(
[[cos(2*PI*k/(6*2^(n-1))),sin(2*PI*k/(6*2^(n-1)))]
$k=0..(6*2^(n-1))],PointsVisible=TRUE,PointSize=1):
plot(C1,P1,AxesVisible=FALSE);
</code></pre>
<pre><code class="lang-matlab">//五角星
r1:=2:
r2:=1:
lt:=[[r1*sin(PI*k*72/180),r1*cos(PI*k*72/180)]
$k=0..4,
[-r2*sin(PI*k*72/180),-r2*cos(PI*k*72/180)]
$k=0..4]:
lt3:=[lt[1], lt[9],
lt[2], lt[10],
lt[3], lt[6],
lt[4], lt[7],
lt[5], lt[8]]:
p1:=plot::Polygon2d(lt3, Closed=TRUE
,FillColor=RGB::Red,Filled=TRUE):
plot(p1,#C);
</code></pre>
<h6 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h6><p> 命令plot::Box创建三维空间中长方体的图形对象，语法格式：</p>
<p>plot::Box(xmin..xmax, ymin..ymax, zmin..zmax, Attributes)</p>
<p>说明：</p>
<p>xmin..xmax, ymin..ymax, zmin..zmax：空间直角坐标 <em>x</em>, <em>y</em>, <em>z</em> 的取值范围，必须xmin&lt;xmax, ymin&lt;ymax, zmin&lt;zmax；</p>
<p>Attributes：图形属性，可选项.</p>
<pre><code class="lang-matlab">Bg:=plot::Box(-delta..delta, -delta..delta, -epsilon..epsilon,Color=RGB::Blue.[0.1]):
</code></pre>
<h5 id="Circle2d"><a href="#Circle2d" class="headerlink" title="Circle2d"></a>Circle2d</h5><p>命令plot::Circle2d(r, [x, y])创建圆心在 (x, y)半径为r的2D圆对象，如果命令中没有给出圆心坐标，则默认将圆心设置在原点处。LinesVisible：线是否显示，默认值是TRUE，即显示，此时可以设置图形属性Color、LineStyle和LineWidth，默认值与命令plot ::Function2d相同；<br>Filled：内部是否填充，默认值是FALSE，即不填充，若修改成TRUE，则可以设置填充颜色FillColor，默认值是FillColor=RGB::Red. </p>
<pre><code class="lang-matlab">C3 :=plot::Circle2d(3,[1, 1],Filled = TRUE,LineColor=RGB::Yellow,FillColor=[0.5,0.6,0.7]):
Point1:=plot::Point2d(1,1,PointSize=2):
plot(C3,Point1):
</code></pre>
<h6 id="Cylinder"><a href="#Cylinder" class="headerlink" title="Cylinder"></a>Cylinder</h6><p>命令plot::Cylinder创建三维空间中圆柱体的图形对象，语法格式：</p>
<p>plot::Cylinder(r, [x1, y1, z1], [x2, y2, z2], Attributes)</p>
<p>说明：</p>
<p>r：圆柱体的半径；</p>
<p>[x1, y1, z1], [x2, y2, z2]：圆柱体的两个底面的圆心的三维坐标；</p>
<p>Attributes：图形属性，可选项</p>
<pre><code class="lang-c++">Cg:=plot::Cylinder(delta, [0,0,-epsilon],[0,0,epsilon], Color=RGB::Blue.[0.1]):
</code></pre>
<h5 id="Arc2d"><a href="#Arc2d" class="headerlink" title="Arc2d"></a>Arc2d</h5><p>plot::Arc2d(r, [x, y], t1..t2, a=a1..a2, Attributes)<br>说明：<br>r：圆弧或扇形所在的圆的半径；<br>[x, y]：可选项，圆弧或扇形所在的圆的圆心的坐标，若缺省，默认值为原点的坐标[0, 0]；<br>t1..t2：可选项，圆心角的范围，若缺省，默认值为0..2*PI，即完整的圆；<br>a=a1..a2：可选项，动画参数及其取值范围，既可以a1<a2，也可以a1>a2；<br>Attributes：可选项，修改图形属性的设置，本次实验需要用到以下图形属性：<br>    (1)  Closed=TRUE，显示圆弧以及圆心角的两条边（半径），也就是扇形的完整轮廓，<br>          默认值是FALSE（仅显示圆弧）；<br>    (2)  Filled=TRUE,  在扇形内填充阴影，默认值是FALSE（不填充）；<br>    (3)  FillPattern=Solid，以默认的红色完全填充扇形内部，默认值是DiagonalLines（斜线）.</a2，也可以a1></p>
<pre><code class="lang-matlab">float(A);
for j from 1 to 5 do
    n:=2^j: //增加或减小正整数n的值，观察图形的变化
    h:=PI/n:  
    t:=-PI/2+k*h:
    S:=numeric::sum(1/2*r(t+h/2)^2*h, k=0..n-1):
    print(j,n,S,float(S-A));
    Fans:=plot::Group2d(plot::Arc2d(r(t+h/2), t..t+h, Closed=TRUE,Filled=TRUE, FillPattern=Solid)
 $ k=0..n-1):
    plot(Fans, Heart, Ly);
end;
</code></pre>
<h5 id="Group2d"><a href="#Group2d" class="headerlink" title="Group2d"></a>Group2d</h5><p>一组相似的图形：</p>
<pre><code class="lang-matlab">delete k,x;
fff:=plot::Group2d(plot::Function2d(k*x,x=0..3) $ k=0..3)://4条直线
plot(fff);
</code></pre>
<h6 id="Group3d"><a href="#Group3d" class="headerlink" title="Group3d"></a>Group3d</h6><p>命令plot::Group3d生成一族三维图形对象，用此命令可以生成空间（直）线族或曲（平）面族，语法格式如下：</p>
<p>plot::Group3d(obj1, obj2, …, Attributes)</p>
<p>说明：obj1, obj2, …：多个三维图形对象，可利用序列运算符$简化重复性的代码.</p>
<h5 id="Text2d"><a href="#Text2d" class="headerlink" title="Text2d"></a>Text2d</h5><p>plot::Text2d(text, [x, y], <a=a1..a2>, <attributes>)<br>命令plot::Text2d常用的图形属性有以下这些：<br>1）TextFont：文本的字体，默认值是[“sans-serif”, 11]；<br>2）TextRotation：文本的旋转角度，弧度制，默认值是0； //逆时针<br>3）HorizontalAlignment：文本相对于添加位置的水平方位，默认值是Left，另外还有Center和Right两种设置；<br>4）VerticalAlignment：文本相对于添加位置的垂直位置，默认值是BaseLine，另外还有Bottom、Center和Top三种设置. </attributes></a=a1..a2></p>
<pre><code class="lang-matlab">Tex1 := plot::Text2d(&quot;cos(x) &lt; sin(x)/x &lt; 1&quot;, [-1.3,1.1]);
</code></pre>
<pre><code class="lang-matlab">plot(plot::Rectangle(0..2, 0..4),
     plot::Point2d([1, 2]),
     plot::Text2d(&quot;Hello world!&quot;, [1, 2*a],
HorizontalAlignment = Left,
a=0.1..2, TextFont = [24]), 
     Axes = Frame, PointColor = RGB::Red, 
PointSize = 3*unit::mm)//动画文本
</code></pre>
<pre><code class="lang-matlab">plot(plot::Circle2d(sqrt(2)),//旋转过的文本
     plot::Text2d(&quot;Hello (1)&quot;, [ 1, 1],
 HorizontalAlignment = Left,
                  TextRotation = PI/4),
     plot::Text2d(&quot;Hello (2)&quot;, [ 1,-1],
 HorizontalAlignment = Left,
                  TextRotation = -PI/4),
     plot::Text2d(&quot;Hello (3)&quot;, [-1,-1],
 HorizontalAlignment = Right,
                  TextRotation = PI/4),
     plot::Text2d(&quot;Hello (4)&quot;, [-1, 1],
 HorizontalAlignment = Right,
                  TextRotation = -PI/4),
     HorizontalAlignment = Left, TextFont = [20])
</code></pre>
<blockquote>
<p>字体属性和数据类型转str可以参见帮助文档，使用举例：</p>
<pre><code class="lang-matlab">ed:=6:
sc:=150:
txc:=[int2text(k)$k=1..ed-1].[&quot;...&quot;]:
exenh:=plot::Group2d(plot::Line2d([k,k],[k,ed])$k=1..ed-1):
exenw:=plot::Group2d(plot::Line2d([k,k],[ed,k])$k=1..ed-1):
exonh:=plot::Group2d(plot::Line2d([-k,k],[-k,ed])$k=1..ed-1):
exonw:=plot::Group2d(plot::Line2d([-k,k],[-ed,k])$k=1..ed-1):
exanh:=plot::Group2d(plot::Line2d([-k,-k],[-k,-ed])$k=1..ed-1):
exanw:=plot::Group2d(plot::Line2d([-k,-k],[-ed,-k])$k=1..ed-1):
exunh:=plot::Group2d(plot::Line2d([k,-k],[k,-ed])$k=1..ed-1):
exunw:=plot::Group2d(plot::Line2d([k,-k],[ed,-k])$k=1..ed-1):
exent:=plot::Group2d(plot::Text2d(
&quot;D&quot;.txc[k],[k-0.6,k-0.6])$k=1..ed):
exont:=plot::Group2d(plot::Text2d(
&quot;D&quot;.txc[k],[-k,k-0.6])$k=1..ed):
exant:=plot::Group2d(plot::Text2d(
&quot;D&quot;.txc[k],[-k,-k+0.3])$k=1..ed):
exunt:=plot::Group2d(plot::Text2d(
&quot;D&quot;.txc[k],[k-0.6,-k+0.3])$k=1..ed):
s1:=plot::Point2d([0.6,1.7],Color=RGB::Blue):
s2:=plot::Point2d([-4.4,2.1],Color=RGB::Blue):
s3:=plot::Point2d([3.9,-3.2],Color=RGB::Blue):
st1:=plot::Text2d(&quot;P1&quot;,[0.4,1.8],TextFont=[&quot;serif&quot;,12,[0,0,1]]):
st2:=plot::Text2d(&quot;P2&quot;,[-5,2.3],TextFont=[&quot;serif&quot;,12,[0,0,1]]):
st3:=plot::Text2d(&quot;P3&quot;,[4.2,-3.5],TextFont=[&quot;serif&quot;,12,[0,0,1]]):
plot(exenh,exenw,exonh,exonw,exanw,exanh,exunh,exunw,
exent,exont,exant,exunt,s1,s2,s3,st1,st2,st3,
#C,#O,Color=RGB::Black,ViewingBox=[-ed..ed,-ed..ed],
Height=sc,Width=sc);
</code></pre>
</blockquote>
<h5 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h5><p>曲面</p>
<p>如果是平面的点位式方程，参数$s,t$，为：</p>
<p>plot::Surface([x0+ux*s+vx*t, y0+uy*s+vy*t, z0+uz*s+vz*t], s=smin..smax, t=tmin..tmax, a=a1..a2, Attributes)</p>
<blockquote>
<p>Surface绘制正圆锥面效果最好。Implicit3d需要AdaptiveMesh且网格线不那么好</p>
<p>plot::Surface绘得的正圆锥面的图像，可看到曲面上显示的网格线由圆周（纬线）和直线（经线）组成，直线族恰好是直线 <em>L</em> 绕 <em>z</em> 轴旋转有向角(k*pi/12,k=[0,23])z得到的，而圆周族是L的25个等距分布的点</p>
</blockquote>
<p>在命令plot::Surface设置ULinesVisible=FALSE和VLinesVisible=FALSE，使得曲面上不显示参数曲线网格；<br>设置Submesh=[4, 4]额外增加采样点密度，并且使用RGBa值颜色，使得等值线更光滑.</p>
<p>设置图形属性FillColorType=Flat，即曲面颜色保持不变（系统默认值FillColorType=Dichromatic会使得色调随着竖坐标值增大而变暖）. </p>
<p>在命令plot::Surface设置XContours=[$-r<em>a..r</em>a step a/2]，使得在曲面上显示被平面族$x=-ra+\frac{ka}2\quad(k=0,1,\dots,4r)$截得的平行截线族.y,z,同理</p>
<p>举例：绘图观察单叶双曲面的 <em>x</em> 等值线</p>
<pre><code class="lang-matlab">S:=plot::Surface([a*cos(u)*sec(v), b*sin(u)*sec(v), c*tan(v)],
u=0..2*PI, v=-arctan(r)..arctan(r), 
Submesh=[4,4],ULinesVisible=FALSE, VLinesVisible=FALSE,
XContours=[$-r*a..r*a step a/2],LineColor=RGB::Black.[0.9]):
plot(S, #C);
</code></pre>
<p>所以可以换成：</p>
<pre><code class="lang-matlab">YContours=[$-r*b..r*b step b/2]
ZContours=[$-r*c..r*c step c/2]//等高线和间距step
</code></pre>
<p>当然是可以一起出现的。</p>
<h5 id="Hatch"><a href="#Hatch" class="headerlink" title="Hatch"></a>Hatch</h5><p>Hatch(f)生成f(定义域内)与x围成的面积</p>
<pre><code class="lang-matlab">Gv:=plot::Function2d(v(t), t=0..3, Color=RGB::Blue):
L3:=plot::Line2d([3,0], [3,v(3)], Color=RGB::Black):
plot(plot::Hatch(Gv), Gv, L3, YAxisTitle=&quot;v&quot;);
</code></pre>
<h5 id="Integral"><a href="#Integral" class="headerlink" title="Integral"></a>Integral</h5><p>积分和(黎曼和)plot::Integral(F, n, a=a1..a2, Attributes)</p>
<p>可选方法有：</p>
<ul>
<li>RiemannLower</li>
<li>RiemannLowerAbs</li>
<li>RiemannUpper</li>
<li>RiemannUpperAbs</li>
<li>RiemannLeft</li>
<li>RiemannMiddle</li>
<li>RiemannRight</li>
</ul>
<pre><code class="lang-matlab">delete j;
m:=8: n:=3*2^(j-1):
Rs:=plot::Integral(Gv,n,j=1..m,IntMethod=RiemannLeft, Frames=m):
plot(Rs, Gv, YAxisTitle=&quot;v&quot;);
</code></pre>
<h5 id="XRotate"><a href="#XRotate" class="headerlink" title="XRotate"></a>XRotate</h5><p>Oxy上曲线绕x旋转得到的立体</p>
<pre><code class="lang-matlab">plot(plot::XRotate(sqrt(x),x=0..5,AdaptiveMesh=3))
//AdaptiveMesh加不加影响不大
</code></pre>
<p>同理有Oxz绕z轴的ZRotate。都默认开启#C</p>
<p>[返回曲面]</p>
<pre><code class="lang-matlab">C:=plot::ZRotate(sqrt(3)/3*x, x=-1..1):
plot(C);
</code></pre>
<h6 id="Rotate3d"><a href="#Rotate3d" class="headerlink" title="Rotate3d"></a>Rotate3d</h6><p>plot::Rotate3d(angle, [x0, y0, z0], [vx, vy, vz], obj1, obj2, …, a=a1..a2, Attributes)</p>
<p>angle：给定的旋转角度，按右手规则约定旋转角的正方向，即右手拇指伸直，其余四指握拳，当拇指指向给定的旋转轴的方向$\vec v=(v_x,v_y,v_z)$，其余四指恰好指向旋转角的正方向；</p>
<p>[x0, y0, z0v], [vx, vy, vz]：可选项，分别是点和向量v的坐标（旋转轴经过点 <em>P</em>，以v为方向向量），默认值分别为[0, 0, 0]（原点）和[0, 0, 1]（ <em>z</em> 轴正方向），如果二者同时缺省，即以 <em>z</em> 轴为旋转轴，如果只缺省一个三元列表，系统只接受表示方向向量的第二项缺省，即以经过点 <em>P</em> 平行于 <em>z</em> 轴的直线为旋转轴；</p>
<p>obj1, obj2, …：一个或多个空间图形对象，从obj2开始是可选项；<br>a=a1..a2：可选项，动画参数及取值范围，既可以a1<a2，也可以a1>a2；<br>Attributes：可选项，修改某些图形属性的默认设置，其中选项Center=[x0, y0, z0]是旋转轴经过的已知点的坐标，选项Axis=[vx, vy, vz]是旋转轴的方向向量的坐标，默认值分别为[0, 0, 0]和[0, 0, 1].</a2，也可以a1></p>
<p>[返回曲线]</p>
<pre><code class="lang-matlab">L0:=plot::Curve3d([v, 0, sqrt(3)/3*v], v=-1..1, Color=RGB::Black.[0.9]):
L:=plot::Rotate3d(angle, [0,0,0], [0,0,1], L0, angle=0..2*PI):
plot(C, L0, L);
</code></pre>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1>
            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2022年05月12日 16:49</p>
        <p>原始链接： <a class="post-url" href="/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/" title="长目录测试">https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/</a></p>
        <footer>
            <a href="https://lr580.github.io">
                <img src="/images/logo.png" alt="lr580">
                lr580
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/&title=《长目录测试》 — lr580's blog&pic=https://lr580.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/&title=《长目录测试》 — lr580's blog&source=QwQ" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《长目录测试》 — lr580's blog&url=https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/&via=https://lr580.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://lr580.github.io/2022/05/12/%E9%95%BF%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/md/" class="color3">md</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="post-toc-text">语法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="post-toc-text">基本语法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="post-toc-text">基本数学函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0"><span class="post-toc-text">取整函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#round"><span class="post-toc-text">round</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="post-toc-text">基本命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4"><span class="post-toc-text">控制命令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%89%93%E5%8D%B0"><span class="post-toc-text">打印</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#if"><span class="post-toc-text">if</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#for"><span class="post-toc-text">for</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="post-toc-text">常量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="post-toc-text">默认参数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A"><span class="post-toc-text">普通</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA%E4%B8%8E%E6%96%87%E6%9C%AC"><span class="post-toc-text">输出与文本</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA%E6%96%B9%E6%B3%95"><span class="post-toc-text">输出方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA%E5%8C%BA%E5%9F%9F%E6%A0%BC%E5%BC%8F"><span class="post-toc-text">输出区域格式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Typeset-Math"><span class="post-toc-text">Typeset Math</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Abbreviate-Output"><span class="post-toc-text">Abbreviate Output</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Pretty-Print"><span class="post-toc-text">Pretty Print</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%8B%E6%A0%87%E8%BE%93%E5%87%BA"><span class="post-toc-text">下标输出</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B2%BE%E7%A1%AE%E5%80%BC"><span class="post-toc-text">精确值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC"><span class="post-toc-text">特殊文本</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">数据类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B8%B8%E8%A7%84"><span class="post-toc-text">常规</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB"><span class="post-toc-text">数组类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%97%E8%A1%A8"><span class="post-toc-text">列表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88"><span class="post-toc-text">集合</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BA%8F%E5%88%97"><span class="post-toc-text">序列</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%A3%E6%95%B0"><span class="post-toc-text">代数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%98%E6%8D%A2"><span class="post-toc-text">表达式变换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%A3%E5%80%BC"><span class="post-toc-text">代值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#subs"><span class="post-toc-text">subs</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#subsex"><span class="post-toc-text">subsex</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%B8%E6%80%81"><span class="post-toc-text">常态</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8C%96%E7%AE%80"><span class="post-toc-text">化简</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#simplify"><span class="post-toc-text">simplify</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Simplify"><span class="post-toc-text">Simplify</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#radsimp"><span class="post-toc-text">radsimp</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#normal"><span class="post-toc-text">normal</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%88%E5%B9%B6"><span class="post-toc-text">合并</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#collect"><span class="post-toc-text">collect</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%87%8D%E5%86%99"><span class="post-toc-text">重写</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#rewrite"><span class="post-toc-text">rewrite</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E8%A7%A3"><span class="post-toc-text">分解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#factor"><span class="post-toc-text">factor</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#partfrac"><span class="post-toc-text">partfrac</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96"><span class="post-toc-text">其他</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B1%82%E5%92%8C"><span class="post-toc-text">求和</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E7%A8%8B"><span class="post-toc-text">方程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E7%A8%8B%E7%9A%84%E5%86%99%E6%B3%95"><span class="post-toc-text">方程的写法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%80%E8%88%AC"><span class="post-toc-text">一般</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0"><span class="post-toc-text">分段函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%A7%A3%E6%96%B9%E7%A8%8B"><span class="post-toc-text">解方程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96-1"><span class="post-toc-text">其他</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6"><span class="post-toc-text">高等数学</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%81%E9%99%90"><span class="post-toc-text">极限</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%87%8D%E6%9E%81%E9%99%90"><span class="post-toc-text">重极限</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B1%82%E5%AF%BC"><span class="post-toc-text">求导</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%98%BE%E5%87%BD%E6%95%B0"><span class="post-toc-text">显函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%9A%90%E5%87%BD%E6%95%B0"><span class="post-toc-text">隐函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B"><span class="post-toc-text">参数方程</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%81%8F%E5%AF%BC%E6%95%B0"><span class="post-toc-text">偏导数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%9B%85%E5%85%8B%E6%AF%94"><span class="post-toc-text">雅克比</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A7%AF%E5%88%86"><span class="post-toc-text">积分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86"><span class="post-toc-text">不定积分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95"><span class="post-toc-text">换元积分法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95"><span class="post-toc-text">分部积分法</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%9A%E7%A7%AF%E5%88%86"><span class="post-toc-text">定积分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86"><span class="post-toc-text">反常积分</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%87%8D%E7%A7%AF%E5%88%86"><span class="post-toc-text">重积分</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%81%E5%80%BC"><span class="post-toc-text">极值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%BB%91%E5%A1%9E%E7%9F%A9%E9%98%B5"><span class="post-toc-text">黑塞矩阵</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80"><span class="post-toc-text">泰勒展开</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="post-toc-text">线性代数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="post-toc-text">矩阵</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="post-toc-text">创建</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E4%B8%80%E8%88%AC%E7%9F%A9%E9%98%B5"><span class="post-toc-text">一般矩阵</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E9%9B%85%E5%85%8B%E6%AF%94%E7%9F%A9%E9%98%B5"><span class="post-toc-text">雅克比矩阵</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="post-toc-text">行列式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97"><span class="post-toc-text">运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%8A%A0%E6%B3%95"><span class="post-toc-text">加法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E4%B9%98%E6%B3%95"><span class="post-toc-text">乘法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="post-toc-text">链接</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%8B%93%E5%B1%95"><span class="post-toc-text">拓展</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E7%A7%A9"><span class="post-toc-text">秩</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%91%E9%87%8F"><span class="post-toc-text">向量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%A8%A1%E9%95%BF"><span class="post-toc-text">模长</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8D%95%E4%BD%8D%E5%90%91%E9%87%8F"><span class="post-toc-text">单位向量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%96%B9%E5%90%91%E8%A7%92"><span class="post-toc-text">方向角</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97-1"><span class="post-toc-text">运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%95%B0%E9%87%8F%E7%A7%AF"><span class="post-toc-text">数量积</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%90%91%E9%87%8F%E7%A7%AF"><span class="post-toc-text">向量积</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%A4%B9%E8%A7%92"><span class="post-toc-text">夹角</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%98%E5%9B%BE"><span class="post-toc-text">绘图</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#plot"><span class="post-toc-text">plot</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%98%E5%9B%BE%E5%8F%82%E6%95%B0"><span class="post-toc-text">绘图参数</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#x-1-%E7%BB%98%E5%88%B6%E6%B0%B4%E5%B9%B3%E8%99%9A%E7%BA%BF-%E9%BB%91%E8%89%B2"><span class="post-toc-text">x &#x3D; 1 绘制水平虚线(黑色)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#y-1-%E7%BB%98%E5%88%B6%E5%9E%82%E7%9B%B4%E8%99%9A%E7%BA%BF-%E9%BB%91%E8%89%B2"><span class="post-toc-text">y &#x3D; -1 绘制垂直虚线(黑色)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%83%E4%BB%B6%E5%8F%82%E6%95%B0"><span class="post-toc-text">元件参数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%A2%9C%E8%89%B2"><span class="post-toc-text">颜色</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#RGB"><span class="post-toc-text">RGB</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#RGBa"><span class="post-toc-text">RGBa</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8A%A8%E7%94%BB%E5%8F%82%E6%95%B0"><span class="post-toc-text">动画参数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BA%BF%E5%BD%A2"><span class="post-toc-text">线形</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BA%BF%E5%AE%BD"><span class="post-toc-text">线宽</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%82%B9%E5%9E%8B"><span class="post-toc-text">点型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%82%B9%E5%AE%BD"><span class="post-toc-text">点宽</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%83%E4%BB%B6"><span class="post-toc-text">元件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Function2d"><span class="post-toc-text">Function2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Function3d"><span class="post-toc-text">Function3d</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Curve2d"><span class="post-toc-text">Curve2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Curve3d"><span class="post-toc-text">Curve3d</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Implicit2d"><span class="post-toc-text">Implicit2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Implicit3d"><span class="post-toc-text">Implicit3d</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Inequaity"><span class="post-toc-text">Inequaity</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Plane"><span class="post-toc-text">Plane</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Polar"><span class="post-toc-text">Polar</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Point2d"><span class="post-toc-text">Point2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Point3d"><span class="post-toc-text">Point3d</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#PointList2d"><span class="post-toc-text">PointList2d</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Sequence"><span class="post-toc-text">Sequence</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Line2d"><span class="post-toc-text">Line2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Line3d"><span class="post-toc-text">Line3d</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Arrow2d"><span class="post-toc-text">Arrow2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Arrow3d"><span class="post-toc-text">Arrow3d</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Rectangle2d"><span class="post-toc-text">Rectangle2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Polygon2d"><span class="post-toc-text">Polygon2d</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Box"><span class="post-toc-text">Box</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Circle2d"><span class="post-toc-text">Circle2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Cylinder"><span class="post-toc-text">Cylinder</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Arc2d"><span class="post-toc-text">Arc2d</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Group2d"><span class="post-toc-text">Group2d</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Group3d"><span class="post-toc-text">Group3d</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Text2d"><span class="post-toc-text">Text2d</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Surface"><span class="post-toc-text">Surface</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Hatch"><span class="post-toc-text">Hatch</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Integral"><span class="post-toc-text">Integral</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#XRotate"><span class="post-toc-text">XRotate</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Rotate3d"><span class="post-toc-text">Rotate3d</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="post-toc-text">例题</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
  
    <a href="/2022/05/12/%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">评论测试</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
<!-- <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script> -->
<!-- <script src="gitment.js"></script> -->
<!-- <script src="//raw.githubusercontent.com/lr580/notes/master/misc/gitment.js"></script> -->
<!-- <script src="//github.com/lr580/notes/blob/master/misc/gitment.js"></script> -->
<!-- <link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script> -->
<!-- <link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://www.wenjunjiang.win/js/gitment.js"></script> -->
<!-- <link rel="stylesheet" href="//billts.site/extra_css/gitment.css">
<script src="//billts.site/js/gitment.js"></script> -->

<script src="https://jjeejj.github.io/js/gitment.js"></script>

<div id="comments">
    <script>
        var gitment = new Gitment({
            owner: 'lr580',
            repo: 'lr580.github.io',
            oauth: {
                client_id: '6e8ca84614e8d6de868c',
                client_secret: 'bd819b13650d089fa5e4708a9a5cd16bb122206d',
            },
        })
        gitment.render('comments')
    </script>
</div>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2022 lr580<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://lr580.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/md/" style="font-size: 10px;">md</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/md/" style="font-size: 10px;">md</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [ ["$","$"], ["\\(","\\)"] ], skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], processEscapes: true } }); MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(); for (var i = 0;
    i
    < all.length; ++i) all[i].SourceElement().parentNode.className +=' has-jax' ; }); </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML
"></script>
</body>
</html>